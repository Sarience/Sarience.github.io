<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[rlwrap解决sqlplus上下键和backspace键找历史命令]]></title>
      <url>/2017/07/02/rlwrap%E8%A7%A3%E5%86%B3sqlplus%E4%B8%8A%E4%B8%8B%E9%94%AE%E5%92%8Cbackspace%E9%94%AE%E6%89%BE%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>在Linux下面使用sqlplus工具的时候默认不能左右移动光标，或者不能使用上下键查找历史命令，使用起来很不方便，影响效率。不过，可以通过第三方工具readline wrap（rlwrap）来解决这个问题。</p>
<p>一、安装readline<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install readline-common </div><div class="line">sudo apt-get install readline-doc</div></pre></td></tr></table></figure></p>
<p>如果没有源，可以自己下载相关的安装包</p>
<p>二:安装rlwrap<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install rlwrap</div></pre></td></tr></table></figure></p>
<p>三、使用rlwrap<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rlwarap sqlplus username/password</div></pre></td></tr></table></figure></p>
<p>也可以将rlwrap命令配置到Oracle用户的.bash_profile文件中</p>
]]></content>
      
        <categories>
            
            <category> Oracle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之建造者模式]]></title>
      <url>/2017/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对<br>象就是指某个类具有不同的属性。建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，<br>而复杂对象的各个部分则经常变化。因此， 建造者模式主要用来解决“对象部分”的需求变化。 这样可以对对象构造的过程进<br>行更加精细的控制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">例子:</div><div class="line">	<span class="comment">//CPU接口</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CPU</span> </span>&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//Intel的cup</span></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">IntelCPU</span> <span class="keyword">implements</span> <span class="title">CPU</span></span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//AMD的cpu</span></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">AMDCPU</span> <span class="keyword">implements</span> <span class="title">CPU</span></span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//内存接口</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Memory</span> </span>&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//金士顿内存</span></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">KingstonMemory</span> <span class="keyword">implements</span> <span class="title">Memory</span></span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//三星内存</span></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">SamsungMemory</span> <span class="keyword">implements</span> <span class="title">Memory</span></span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//主板内存</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mainboard</span> </span>&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="comment">//华硕主板</span></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">AsusMainboard</span> <span class="keyword">implements</span> <span class="title">Mainboard</span></span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//技嘉主板</span></div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">GaMainboard</span> <span class="keyword">implements</span> <span class="title">Mainboard</span></span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//计算机</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</div><div class="line">	    <span class="keyword">private</span> CPU cpu;  </div><div class="line">	    <span class="keyword">private</span> Memory memory;  </div><div class="line">	    <span class="keyword">private</span> Mainboard mainboard;</div><div class="line">	    get/set</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//计算机的builder的接口</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerBuilder</span> </span>&#123;  </div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCPU</span><span class="params">()</span></span>;    </div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMemory</span><span class="params">()</span></span>;    </div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMainboard</span><span class="params">()</span></span>;    </div><div class="line">	    <span class="function"><span class="keyword">public</span> Computer <span class="title">getComputer</span><span class="params">()</span></span>;   </div><div class="line">	&#125;  </div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">//联想电脑的builder</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenoveComputerBuilder</span> <span class="keyword">implements</span> <span class="title">ComputerBuilder</span> </span>&#123;  </div><div class="line">	   <span class="keyword">private</span> Computer lenoveComputer;    </div><div class="line">	   <span class="function"><span class="keyword">public</span> <span class="title">LenoveComputerBuilder</span><span class="params">()</span></span>&#123;    </div><div class="line">	       lenoveComputer = <span class="keyword">new</span> Computer();    </div><div class="line">	   &#125;    </div><div class="line">	   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCPU</span><span class="params">()</span> </span>&#123;  </div><div class="line">	       lenoveComputer.setCpu(<span class="keyword">new</span> IntelCPU());  </div><div class="line">	   &#125;  </div><div class="line">	   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMemory</span><span class="params">()</span> </span>&#123;  </div><div class="line">	       lenoveComputer.setMemory(<span class="keyword">new</span> KingstonMemory());  </div><div class="line">	   &#125;  </div><div class="line">	   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMainboard</span><span class="params">()</span> </span>&#123;  </div><div class="line">	       lenoveComputer.setMainboard(<span class="keyword">new</span> AsusMainboard());  </div><div class="line">	   &#125;  </div><div class="line">	   <span class="function"><span class="keyword">public</span> Computer <span class="title">getComputer</span><span class="params">()</span> </span>&#123;  </div><div class="line">	       <span class="keyword">return</span> lenoveComputer;  </div><div class="line">	   &#125;  </div><div class="line">	&#125;  </div><div class="line"></div><div class="line">	<span class="comment">//惠普电脑的builder</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HPComputerBuilder</span> <span class="keyword">implements</span> <span class="title">ComputerBuilder</span> </span>&#123;  </div><div class="line">	   <span class="keyword">private</span> Computer HPComputer;    </div><div class="line">	   </div><div class="line">	   <span class="function"><span class="keyword">public</span> <span class="title">HPComputerBuilder</span><span class="params">()</span></span>&#123;  </div><div class="line">	       HPComputer = <span class="keyword">new</span> Computer();  </div><div class="line">	   &#125;  </div><div class="line">	   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCPU</span><span class="params">()</span> </span>&#123;  </div><div class="line">	       HPComputer.setCpu(<span class="keyword">new</span> AMDCPU());  </div><div class="line">	   &#125;  </div><div class="line">	   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMemory</span><span class="params">()</span> </span>&#123;  </div><div class="line">	       HPComputer.setMemory(<span class="keyword">new</span> SamsungMemory());  </div><div class="line">	   &#125;  </div><div class="line">	   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMainboard</span><span class="params">()</span> </span>&#123;  </div><div class="line">	       HPComputer.setMainboard(<span class="keyword">new</span> GaMainboard());  </div><div class="line">	   &#125;  </div><div class="line">	   <span class="function"><span class="keyword">public</span> Computer <span class="title">getComputer</span><span class="params">()</span> </span>&#123;  </div><div class="line">	       <span class="keyword">return</span> HPComputer;  </div><div class="line">	   &#125;  </div><div class="line">	&#125; </div><div class="line"></div><div class="line">	<span class="comment">//Director类(导演)</span></div><div class="line">	<span class="comment">//指导如何具体的创造电脑</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line">	    <span class="keyword">private</span> ComputerBuilder builder;     </div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(ComputerBuilder builder)</span> </span>&#123;     </div><div class="line">	        <span class="keyword">this</span>.builder = builder;     </div><div class="line">	    &#125;    </div><div class="line">	    <span class="comment">//用户自定义的自造顺序 具体指导各种builder如何创建电脑</span></div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;</div><div class="line">	    	</div><div class="line">	    	builder.buildCPU();</div><div class="line">	    	builder.buildMemory();</div><div class="line">	    	builder.buildMainboard();</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//测试类</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Computer lenoveComputer = <span class="keyword">null</span>;    </div><div class="line">        		ComputerBuilder lenoveComputerBuilder = <span class="keyword">new</span> LenoveComputerBuilder();    </div><div class="line">		Director director = <span class="keyword">new</span> Director(lenoveComputerBuilder);</div><div class="line">		director.construct();</div><div class="line">		lenoveComputer = lenoveComputerBuilder.getComputer();</div><div class="line">		System.out.println(lenoveComputer);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建适合对象的多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。</p>
<p>例如一个Person类是由头、身体、脚三个对象组成，那么我们在建造者模式中就要先分别创造出这三个部分然后再把他们组装成一个Person对象。</p>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之单例模式]]></title>
      <url>/2017/05/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：<br>1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。<br>2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。<br>3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。</p>
<h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//简单的单例类  饿汉模式</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line"></div><div class="line">		<span class="comment">/* 持有私有静态实例，防止被引用*/</span>  </div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </div><div class="line"></div><div class="line">		<span class="comment">/* 私有构造方法，防止被实例化 */</span>  </div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </div><div class="line">		&#125;  </div><div class="line"></div><div class="line">		<span class="comment">/* 静态工程方法，返回Singleton实例 */</span>  </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">		    <span class="keyword">return</span> instance;  </div><div class="line">		&#125;  </div><div class="line"></div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这个类是可以实现单例模式的，但是存在不少问题,比如在类中不管用户是否要使用该类的对象,就先创建好了一个实例放在内存中。</p>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//简单的单例类 懒汉模式</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line"></div><div class="line">		<span class="comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span>  </div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </div><div class="line"></div><div class="line">		<span class="comment">/* 私有构造方法，防止被实例化 */</span>  </div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </div><div class="line">		&#125;  </div><div class="line"></div><div class="line">		<span class="comment">/* 静态工程方法，创建实例 */</span>  </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">		    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; </div><div class="line">		        instance = <span class="keyword">new</span> Singleton();  </div><div class="line">		    &#125;  </div><div class="line">		    <span class="keyword">return</span> instance;  </div><div class="line">		&#125;  </div><div class="line"></div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">		    instance = <span class="keyword">new</span> Singleton();  </div><div class="line">		&#125;  </div><div class="line">		<span class="keyword">return</span> instance;  </div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>但是，synchronized作为修饰符在方法上使用,在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">		    <span class="keyword">synchronized</span> (instance) &#123;  </div><div class="line">		        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">		            instance = <span class="keyword">new</span> Singleton();  </div><div class="line">		        &#125;  </div><div class="line">		    &#125;  </div><div class="line">		&#125;  </div><div class="line">		<span class="keyword">return</span> instance;  </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>似乎解决了之前提到的问题，将synchronized关键字加在了方法内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的。<br>    看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句并非是一个原子操作,在 JVM 中这句代码大概做了下面 3 件事情:</p>
<ol>
<li><p>给 new的对象 分配内存</p>
</li>
<li><p>调用 Singleton 的构造函数来初始化成员变量</p>
</li>
<li><p>将引用instance指向分配的内存空间（执行完这步 instance 就为非 null 了）<br> 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，另外一个线程B抢夺到了CPU的执行权,这时instance已经是非null了（但却没有初始化），所以线程B会直接返回 instance，然后使用，结果就会出现问题了(因为对象还没有初始化)。</p>
</li>
</ol>
<p>还有另外一种解决方案:使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的(就是加载完毕后别的线程才能使用)。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">	  </div><div class="line">		<span class="comment">/* 私有构造方法，防止被实例化 */</span>  </div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </div><div class="line">		&#125;  </div><div class="line"></div><div class="line">		<span class="comment">/* 此处使用一个内部类来维护单例 */</span>  </div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;  </div><div class="line">		    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </div><div class="line">		&#125;  </div><div class="line"></div><div class="line">		<span class="comment">/* 获取实例 */</span>  </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">		    <span class="keyword">return</span> SingletonFactory.instance;  </div><div class="line">		&#125;  </div><div class="line"></div><div class="line">		<span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>  </div><div class="line">		<span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </div><div class="line">		    <span class="keyword">return</span> getInstance();  </div><div class="line">		&#125;  </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>但是如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。</p>
<p>同时，我们还可以使用反射去创建这个类的对象，即使它的构造器是私有的，我们也是可以调用到的。那么这个时候我们就需要再次修改代码去访问别人反射调用构造器。<br>例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在构造器中控制一下，构造器只允许调用一次,之后在调用就抛出异常</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag;</div><div class="line">		<span class="comment">/* 私有构造方法，防止被实例化 */</span>  </div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </div><div class="line">			<span class="keyword">if</span>(!flag)&#123;</div><div class="line">				flag = <span class="keyword">false</span>;</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不能多次创建单例对象"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;  </div><div class="line"></div><div class="line">		<span class="comment">/* 此处使用一个内部类来维护单例 */</span>  </div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;  </div><div class="line">		    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">		&#125;  </div><div class="line"></div><div class="line">		<span class="comment">/* 获取实例 */</span>  </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">		    <span class="keyword">return</span> SingletonFactory.instance;  </div><div class="line">		&#125;  </div><div class="line"></div><div class="line">		<span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>  </div><div class="line">		<span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </div><div class="line">		    <span class="keyword">return</span> getInstance();  </div><div class="line">		&#125;  </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>反射的问题处理完了之后，这里还有一个问题，就是如果把单例对象进行序列化然后再反序列化,那么内存中就会出现俩个一样的单例对象，只是内存地址不同。这种情况我们可以使用readResolve方法来防止。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;.....&#125;</div></pre></td></tr></table></figure></p>
<p>ObjectInputStream 会检查对象的class是否定义了readResolve方法。如果定义了，将由readResolve方法指定返回的对象。返回对象的类型一定要是兼容的，否则会抛出ClassCastException 。<br>例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton8</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;  </div><div class="line"></div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7863921642928237696L</span>;</div><div class="line"></div><div class="line">		<span class="comment">/* 此处使用一个内部类来维护单例 */</span>  </div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;  </div><div class="line">		    <span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line">			<span class="keyword">private</span> <span class="keyword">static</span> Singleton8 instance = <span class="keyword">new</span> Singleton8()&#123;&#125;;</div><div class="line">		&#125;  </div><div class="line">		</div><div class="line">		<span class="comment">//测试方式,把单例对象序列化后再反序列化从而获得一个新的对象 就相当于复制了一个单例对象</span></div><div class="line">		<span class="function"><span class="keyword">public</span> Singleton8 <span class="title">copy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;  </div><div class="line">		        ByteArrayOutputStream os = <span class="keyword">new</span> ByteArrayOutputStream();  </div><div class="line">		        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(os);  </div><div class="line">		        oos.writeObject(Singleton8.getInstance());  </div><div class="line">		          </div><div class="line">		        InputStream is = <span class="keyword">new</span> ByteArrayInputStream(os.toByteArray());  </div><div class="line">		        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(is);  </div><div class="line">		        Singleton8 obj = (Singleton8) ois.readObject();  </div><div class="line">		        <span class="keyword">return</span> obj;  </div><div class="line">		&#125; </div><div class="line">		</div><div class="line">		<span class="comment">/* 获取实例 */</span>  </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton8 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">		    <span class="keyword">return</span> SingletonFactory.instance;  </div><div class="line">		&#125;  </div><div class="line"></div><div class="line">		<span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span>  </div><div class="line">		<span class="comment">/* 把这个方法注释前和注释后来运行测试代码观察结果 */</span>  </div><div class="line">		<span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;  </div><div class="line">		    <span class="keyword">return</span> getInstance();  </div><div class="line">		&#125;  </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>最后再思考一个问题  :  是否可以使用枚举来实现单例模式?</p>
<p>使用静态工厂方法或者传统地声明一个public的实例域（并将构造器声明为private），都可以实现单例模式，但是使用反射机制都可以获取不同的实例。</p>
<p>自从枚举出现以后，单元素枚举就成为了单例的绝佳选择。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Singleton singleton1 = Singleton.INSTANCE;</div><div class="line">        Singleton singleton2 = Singleton.INSTANCE;</div><div class="line">        System.out.print(singleton1==singleton2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果是true，说明单元素枚举的单例方案确实可行。</p>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之抽象工厂模式]]></title>
      <url>/2017/05/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。（将工厂类抽象出来，以便之后进行添加新的工厂类）</p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"> 	<span class="comment">//发送短信和邮件的接口</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;  </div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;  </div><div class="line">	&#125; </div><div class="line"></div><div class="line">	<span class="comment">//发送邮件的实现类</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;  </div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;  </div><div class="line">	        System.out.println(<span class="string">"发送邮件!"</span>);  </div><div class="line">	    &#125;  </div><div class="line">	&#125;  </div><div class="line">	<span class="comment">//发送短信的实现类</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;  </div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;  </div><div class="line">	        System.out.println(<span class="string">"发送短信!"</span>);  </div><div class="line">	    &#125;  </div><div class="line">	&#125;  </div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WX</span> <span class="title">imp</span> <span class="title">Sender</span></span>&#123;</div><div class="line"> 	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</div><div class="line">		syso(“微信发送”);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendWXFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;  </div><div class="line">	    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span></span>&#123;  </div><div class="line">	        <span class="keyword">return</span> <span class="keyword">new</span> WX();  </div><div class="line">	    &#125;  </div><div class="line">	&#125;  </div><div class="line"></div><div class="line">	<span class="comment">//给工厂类一个接口</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;  </div><div class="line">	    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span></span>;  </div><div class="line">	&#125;  </div><div class="line">	<span class="comment">//两个工厂的实现类</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMailFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;  </div><div class="line">	    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span></span>&#123;  </div><div class="line">	        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();  </div><div class="line">	    &#125;  </div><div class="line">	&#125;  </div><div class="line">	</div><div class="line"></div><div class="line">	<span class="comment">//测试类</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">	  </div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">	        Provider provider = <span class="keyword">new</span> SendMailFactory();  </div><div class="line">	        Sender sender = provider.produce();  </div><div class="line">	        sender.Send();  </div><div class="line">	    &#125;  </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这个模式的好处就是，如果你现在想增加一个功能：发送及时信息，则只需做一个实现类实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好</p>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之工厂模式]]></title>
      <url>/2017/05/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>工厂方法模式分为三种：普通工厂模式   多个工厂方法模式   静态工厂方法模式</p>
<h3 id="普通工厂"><a href="#普通工厂" class="headerlink" title="普通工厂"></a>普通工厂</h3><p>就是建立一个工厂类，对实现了同一接口的产品类进行实例的创建（工厂类根据不同的参数返回不同的对象）<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//发送短信和邮件的接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//发送邮件的实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"发送邮件!"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">//发送短信的实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"发送短信!"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">//创建工厂类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;  </div><div class="line">    <span class="comment">//工厂方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">(String type)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (<span class="string">"mail"</span>.equals(type)) &#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MailSender();  </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"sms"</span>.equals(type)) &#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            System.out.println(<span class="string">"请输入正确的类型!"</span>);  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125; 	</div><div class="line"></div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;  </div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        SendFactory factory = <span class="keyword">new</span> SendFactory();  </div><div class="line">        Sender sender = factory.produce(<span class="string">"sms"</span>);</div><div class="line">        sender.Send();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="多个工厂方法模式"><a href="#多个工厂方法模式" class="headerlink" title="多个工厂方法模式"></a>多个工厂方法模式</h3><p>是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。(顾名思义，就是在工厂类中定义多个方法，每个方法返回一个对象，也可以简单的理解为普通工厂是根据参数返回不同对象，而多个工厂方法是根据方法返回不同对象)</p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将上面的代码做下修改，改动下SendFactory类就行</span></div><div class="line">	<span class="comment">//这个就不用根据用户传的字符串类创建对象了</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;  </div><div class="line">      </div><div class="line">	    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;  </div><div class="line">	        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();  </div><div class="line">	    &#125;  </div><div class="line">	      </div><div class="line">	    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;  </div><div class="line">	        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();  </div><div class="line">	    &#125;  </div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//测试类</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;  </div><div class="line">	  </div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">	        SendFactory factory = <span class="keyword">new</span> SendFactory();  </div><div class="line">	        Sender sender = factory.produceMail();  </div><div class="line">	        sender.Send();  </div><div class="line">	    &#125;  </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="静态工厂方法模式"><a href="#静态工厂方法模式" class="headerlink" title="静态工厂方法模式"></a>静态工厂方法模式</h3><p>将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。(可以看做是多工厂方法模式的升级版，将工厂类方法声明为静态的，那么就不需要创建工厂实例，直接调用方法即可)</p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">//测试类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      </div><div class="line">        Sender sender = SendFactory.produceMail();  </div><div class="line">        sender.Send();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之概述]]></title>
      <url>/2017/05/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。<br>项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。</p>
<h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p><strong>创建型模式</strong>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p><strong>结构型模式</strong>，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p><strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java线程]]></title>
      <url>/2017/05/04/Java%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>线程状态图<br><img src="https://sarience.github.io/img/pic/thread_lifecycle.jpg" alt=""></p>
<p>说明：<br>线程共包括以下5种状态。</p>
<ol>
<li>新建状态(New)         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li>
<li>就绪状态(Runnable): 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li>
<li>运行状态(Running) : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li>
<li>阻塞状态(Blocked)  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<br> (01) 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。<br> (02) 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。<br> (03) 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
<li>死亡状态(Dead)    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ol>
<p>这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。<br>Object类，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。<br>Thread类，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。<br>synchronized，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。</p>
<h4 id="Thread和Runnable简介"><a href="#Thread和Runnable简介" class="headerlink" title="Thread和Runnable简介"></a>Thread和Runnable简介</h4><p>Runnable 是一个接口，该接口中只包含了一个run()方法。它的定义如下：</p>
<p>public interface Runnable {<br>    public abstract void run();<br>}<br>Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；然后，通过new Thread(new A())等方式新建线程。</p>
<p>Thread 是一个类。Thread本身就实现了Runnable接口。它的声明如下：</p>
<p>public class Thread implements Runnable {}<br>Thread的作用，实现多线程。</p>
<h5 id="Thread和Runnable的异同点"><a href="#Thread和Runnable的异同点" class="headerlink" title="Thread和Runnable的异同点"></a>Thread和Runnable的异同点</h5><p>Thread 和 Runnable 的相同点：都是“多线程的实现方式”。<br>Thread 和 Runnable 的不同点：<br>Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。<br>此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。<br>通常，建议通过“Runnable”实现多线程！</p>
<h5 id="Thread和Runnable的多线程示例"><a href="#Thread和Runnable的多线程示例" class="headerlink" title="Thread和Runnable的多线程示例"></a>Thread和Runnable的多线程示例</h5><ol>
<li>Thread的多线程示例<br>下面通过示例更好的理解Thread和Runnable，借鉴网上一个例子比较具有说服性的例子。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ThreadTest.java 源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">10</span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123; </div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.ticket&gt;<span class="number">0</span>)&#123;</div><div class="line">                System.out.println(<span class="keyword">this</span>.getName()+<span class="string">" 卖票：ticket"</span>+<span class="keyword">this</span>.ticket--);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">// 启动3个线程t1,t2,t3；每个线程各卖10张票！</span></div><div class="line">        MyThread t1=<span class="keyword">new</span> MyThread();</div><div class="line">        MyThread t2=<span class="keyword">new</span> MyThread();</div><div class="line">        MyThread t3=<span class="keyword">new</span> MyThread();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>Thread-0 卖票：ticket10<br>Thread-1 卖票：ticket10<br>Thread-2 卖票：ticket10<br>Thread-1 卖票：ticket9<br>Thread-0 卖票：ticket9<br>Thread-1 卖票：ticket8<br>Thread-2 卖票：ticket9<br>Thread-1 卖票：ticket7<br>Thread-0 卖票：ticket8<br>Thread-1 卖票：ticket6<br>Thread-2 卖票：ticket8<br>Thread-1 卖票：ticket5<br>Thread-0 卖票：ticket7<br>Thread-1 卖票：ticket4<br>Thread-2 卖票：ticket7<br>Thread-1 卖票：ticket3<br>Thread-0 卖票：ticket6<br>Thread-1 卖票：ticket2<br>Thread-2 卖票：ticket6<br>Thread-2 卖票：ticket5<br>Thread-2 卖票：ticket4<br>Thread-1 卖票：ticket1<br>Thread-0 卖票：ticket5<br>Thread-2 卖票：ticket3<br>Thread-0 卖票：ticket4<br>Thread-2 卖票：ticket2<br>Thread-0 卖票：ticket3<br>Thread-2 卖票：ticket1<br>Thread-0 卖票：ticket2<br>Thread-0 卖票：ticket1</p>
</blockquote>
<p>结果说明：<br>(01) MyThread继承于Thread，它是自定义个线程。每个MyThread都会卖出10张票。<br>(02) 主线程main创建并启动3个MyThread子线程。每个子线程都各自卖出了10张票。</p>
<ol>
<li>Runnable的多线程示例<br>下面，我们对上面的程序进行修改。通过Runnable实现一个接口，从而实现多线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// RunnableTest.java 源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">10</span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123; </div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.ticket&gt;<span class="number">0</span>)&#123;</div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" 卖票：ticket"</span>+<span class="keyword">this</span>.ticket--);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        MyThread mt=<span class="keyword">new</span> MyThread();</div><div class="line"></div><div class="line">        <span class="comment">// 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！</span></div><div class="line">        Thread t1=<span class="keyword">new</span> Thread(mt);</div><div class="line">        Thread t2=<span class="keyword">new</span> Thread(mt);</div><div class="line">        Thread t3=<span class="keyword">new</span> Thread(mt);</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>Thread-0 卖票：ticket10<br>Thread-2 卖票：ticket8<br>Thread-1 卖票：ticket9<br>Thread-2 卖票：ticket6<br>Thread-0 卖票：ticket7<br>Thread-2 卖票：ticket4<br>Thread-1 卖票：ticket5<br>Thread-2 卖票：ticket2<br>Thread-0 卖票：ticket3<br>Thread-1 卖票：ticket1</p>
</blockquote>
<p>结果说明：<br>(01) 和上面“MyThread继承于Thread”不同；这里的MyThread实现了Thread接口。<br>(02) 主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。</p>
<h5 id="start-和-run-的区别说明"><a href="#start-和-run-的区别说明" class="headerlink" title="start() 和 run()的区别说明"></a>start() 和 run()的区别说明</h5><p>start() : 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。<br>run()   : run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！</p>
<p>下面以代码来进行说明。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        ...</div><div class="line">    &#125; </div><div class="line">&#125;;</div><div class="line">MyThread mythread = <span class="keyword">new</span> MyThread();</div></pre></td></tr></table></figure></p>
<p>mythread.start()会启动一个新线程，并在新线程中运行run()方法。<br>而mythread.run()则会直接在当前线程中运行run()方法，并不会启动一个新线程来运行run()。</p>
<p>start() 和 run()的区别示例</p>
<p>下面，通过一个简单示例演示它们之间的区别。源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Demo.java 的源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" is running"</span>);</div><div class="line">    &#125; </div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Thread mythread=<span class="keyword">new</span> MyThread(<span class="string">"mythread"</span>);</div><div class="line"></div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" call mythread.run()"</span>);</div><div class="line">        mythread.run();</div><div class="line"></div><div class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" call mythread.start()"</span>);</div><div class="line">        mythread.start();</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>main call mythread.run()<br>main is running<br>main call mythread.start()<br>mythread is running</p>
</blockquote>
<p>结果说明：<br>(01) Thread.currentThread().getName()是用于获取“当前线程”的名字。当前线程是指正在cpu中调度执行的线程。<br>(02) mythread.run()是在“主线程main”中调用的，该run()方法直接运行在“主线程main”上。<br>(03) mythread.start()会启动“线程mythread”，“线程mythread”启动之后，会调用run()方法；此时的run()方法是运行在“线程mythread”上。</p>
<ol>
<li>synchronized原理</li>
</ol>
<p>在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。<br>当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。<br>不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。</p>
<ol>
<li>synchronized基本规则</li>
</ol>
<p>我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。<br>第一条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。<br>第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。<br>第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</p>
<p>第一条<br>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。<br>下面是“synchronized代码块”对应的演示程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" loop "</span> + i);  </div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">            &#125;</div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Runnable demo = <span class="keyword">new</span> MyRunable();     <span class="comment">// 新建“Runnable对象”</span></div><div class="line"></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(demo, <span class="string">"t1"</span>);  <span class="comment">// 新建“线程t1”, t1是基于demo这个Runnable对象</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(demo, <span class="string">"t2"</span>);  <span class="comment">// 新建“线程t2”, t2是基于demo这个Runnable对象</span></div><div class="line">        t1.start();                          <span class="comment">// 启动“线程t1”</span></div><div class="line">        t2.start();                          <span class="comment">// 启动“线程t2” </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t1 loop 0<br>t1 loop 1<br>t1 loop 2<br>t1 loop 3<br>t1 loop 4<br>t2 loop 0<br>t2 loop 1<br>t2 loop 2<br>t2 loop 3<br>t2 loop 4</p>
</blockquote>
<p>结果说明：<br>run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于”demo这个Runnable对象”创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。</p>
<p>如果你确认，你搞清楚这个问题了。那我们将上面的代码进行修改，然后再运行看看结果怎么样，看看你是否会迷糊。修改后的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" loop "</span> + i);  </div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">            &#125;</div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Thread t1 = <span class="keyword">new</span> MyThread(<span class="string">"t1"</span>);  <span class="comment">// 新建“线程t1”</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> MyThread(<span class="string">"t2"</span>);  <span class="comment">// 新建“线程t2”</span></div><div class="line">        t1.start();                          <span class="comment">// 启动“线程t1”</span></div><div class="line">        t2.start();                          <span class="comment">// 启动“线程t2” </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码说明：<br>比较Demo1_2 和 Demo1_1，我们发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。<br>幸运的是，在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！<br>那么，Demo1_2的执行流程是不是和Demo1_1一样呢？<br>运行结果：</p>
<blockquote>
<p>t1 loop 0<br>t2 loop 0<br>t1 loop 1<br>t2 loop 1<br>t1 loop 2<br>t2 loop 2<br>t1 loop 3<br>t2 loop 3<br>t1 loop 4<br>t2 loop 4</p>
</blockquote>
<p>结果说明：<br>如果这个结果一点也不令你感到惊讶，那么我相信你对synchronized和this的认识已经比较深刻了。否则的话，请继续阅读这里的分析。<br>synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。<br>对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。</p>
<p>第二条<br>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。<br>下面是“synchronized代码块”对应的演示程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 含有synchronized同步块的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" synMethod loop "</span> + i);  </div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">            &#125;</div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 非同步的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonSynMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>);</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" nonSynMethod loop "</span> + i);  </div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">final</span> Count count = <span class="keyword">new</span> Count();</div><div class="line">        <span class="comment">// 新建t1, t1会调用“count对象”的synMethod()方法</span></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        count.synMethod();</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="string">"t1"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 新建t2, t2会调用“count对象”的nonSynMethod()方法</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        count.nonSynMethod();</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="string">"t2"</span>);  </div><div class="line"></div><div class="line"></div><div class="line">        t1.start();  <span class="comment">// 启动t1</span></div><div class="line">        t2.start();  <span class="comment">// 启动t2</span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t1 synMethod loop 0<br>t2 nonSynMethod loop 0<br>t1 synMethod loop 1<br>t2 nonSynMethod loop 1<br>t1 synMethod loop 2<br>t2 nonSynMethod loop 2<br>t1 synMethod loop 3<br>t2 nonSynMethod loop 3<br>t1 synMethod loop 4<br>t2 nonSynMethod loop 4</p>
</blockquote>
<p>结果说明：<br>主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。</p>
<p>第三条<br>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。<br>我们将上面的例子中的nonSynMethod()方法体的也用synchronized(this)修饰。修改后的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 含有synchronized同步块的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" synMethod loop "</span> + i);  </div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">            &#125;</div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 也包含synchronized同步块的方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonSynMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                    Thread.sleep(<span class="number">100</span>);</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" nonSynMethod loop "</span> + i);  </div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">final</span> Count count = <span class="keyword">new</span> Count();</div><div class="line">        <span class="comment">// 新建t1, t1会调用“count对象”的synMethod()方法</span></div><div class="line">        Thread t1 = <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        count.synMethod();</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="string">"t1"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 新建t2, t2会调用“count对象”的nonSynMethod()方法</span></div><div class="line">        Thread t2 = <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        count.nonSynMethod();</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="string">"t2"</span>);  </div><div class="line"></div><div class="line"></div><div class="line">        t1.start();  <span class="comment">// 启动t1</span></div><div class="line">        t2.start();  <span class="comment">// 启动t2</span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t1 synMethod loop 0<br>t1 synMethod loop 1<br>t1 synMethod loop 2<br>t1 synMethod loop 3<br>t1 synMethod loop 4<br>t2 nonSynMethod loop 0<br>t2 nonSynMethod loop 1<br>t2 nonSynMethod loop 2<br>t2 nonSynMethod loop 3<br>t2 nonSynMethod loop 4</p>
</blockquote>
<p>结果说明：<br>主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。</p>
<ol>
<li>synchronized方法 和 synchronized代码块</li>
</ol>
<p>“synchronized方法”是用synchronized修饰方法，而 “synchronized代码块”则是用synchronized修饰代码块。</p>
<p>synchronized方法示例</p>
<p>public synchronized void foo1() {<br>    System.out.println(“synchronized methoed”);<br>}<br>synchronized代码块</p>
<p>public void foo2() {<br>    synchronized (this) {<br>        System.out.println(“synchronized methoed”);<br>    }<br>}<br>synchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。</p>
<p>synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率。下面通过一个示例来演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Demo4.java的源码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)</div><div class="line">            ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synBlock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>( <span class="keyword">this</span> ) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)</div><div class="line">                ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Demo4 demo = <span class="keyword">new</span> Demo4();</div><div class="line"></div><div class="line">        <span class="keyword">long</span> start, diff;</div><div class="line">        start = System.currentTimeMillis();                <span class="comment">// 获取当前时间(millis)</span></div><div class="line">        demo.synMethod();                                <span class="comment">// 调用“synchronized方法”</span></div><div class="line">        diff = System.currentTimeMillis() - start;        <span class="comment">// 获取“时间差值”</span></div><div class="line">        System.out.println(<span class="string">"synMethod() : "</span>+ diff);</div><div class="line">        </div><div class="line">        start = System.currentTimeMillis();                <span class="comment">// 获取当前时间(millis)</span></div><div class="line">        demo.synBlock();                                <span class="comment">// 调用“synchronized方法块”</span></div><div class="line">        diff = System.currentTimeMillis() - start;        <span class="comment">// 获取“时间差值”</span></div><div class="line">        System.out.println(<span class="string">"synBlock()  : "</span>+ diff);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(某一次)执行结果：</p>
<p>synMethod() : 11<br>synBlock() : 3</p>
<h4 id="实例锁-和-全局锁"><a href="#实例锁-和-全局锁" class="headerlink" title="实例锁 和 全局锁"></a>实例锁 和 全局锁</h4><p>实例锁 – 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。<br>               实例锁对应的就是synchronized关键字。<br>全局锁 – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。<br>               全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。</p>
<p>关于“实例锁”和“全局锁”有一个很形象的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pulbic <span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncA</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncB</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cSyncA</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cSyncB</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。<br>(01) x.isSyncA()与x.isSyncB()<br>(02) x.isSyncA()与y.isSyncA()<br>(03) x.cSyncA()与y.cSyncB()<br>(04) x.isSyncA()与Something.cSyncA()</p>
<p>(01) 不能被同时访问。因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LockTest1.java的源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : isSyncA"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : isSyncB"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest1</span> </span>&#123;</div><div class="line"></div><div class="line">    Something x = <span class="keyword">new</span> Something();</div><div class="line">    Something y = <span class="keyword">new</span> Something();</div><div class="line"></div><div class="line">    <span class="comment">// 比较(01) x.isSyncA()与x.isSyncB() </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 新建t11, t11会调用 x.isSyncA()</span></div><div class="line">        Thread t11 = <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        x.isSyncA();</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="string">"t11"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 新建t12, t12会调用 x.isSyncB()</span></div><div class="line">        Thread t12 = <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        x.isSyncB();</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="string">"t12"</span>);  </div><div class="line"></div><div class="line"></div><div class="line">        t11.start();  <span class="comment">// 启动t11</span></div><div class="line">        t12.start();  <span class="comment">// 启动t12</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        LockTest1 demo = <span class="keyword">new</span> LockTest1();</div><div class="line">        demo.test1();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t11 : isSyncA<br>t11 : isSyncA<br>t11 : isSyncA<br>t11 : isSyncA<br>t11 : isSyncA<br>t12 : isSyncB<br>t12 : isSyncB<br>t12 : isSyncB<br>t12 : isSyncB<br>t12 : isSyncB</p>
</blockquote>
<p>(02) 可以同时被访问。因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LockTest2.java的源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : isSyncA"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : isSyncB"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cSyncA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : cSyncA"</span>);</div><div class="line">            &#125; </div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cSyncB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : cSyncB"</span>);</div><div class="line">            &#125; </div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    Something x = <span class="keyword">new</span> Something();</div><div class="line">    Something y = <span class="keyword">new</span> Something();</div><div class="line"></div><div class="line">    <span class="comment">// 比较(02) x.isSyncA()与y.isSyncA()</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 新建t21, t21会调用 x.isSyncA()</span></div><div class="line">        Thread t21 = <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        x.isSyncA();</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="string">"t21"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 新建t22, t22会调用 x.isSyncB()</span></div><div class="line">        Thread t22 = <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        y.isSyncA();</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="string">"t22"</span>);  </div><div class="line"></div><div class="line"></div><div class="line">        t21.start();  <span class="comment">// 启动t21</span></div><div class="line">        t22.start();  <span class="comment">// 启动t22</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        LockTest2 demo = <span class="keyword">new</span> LockTest2();</div><div class="line"></div><div class="line">        demo.test2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t21 : isSyncA<br>t22 : isSyncA<br>t21 : isSyncA<br>t22 : isSyncA<br>t21 : isSyncA<br>t22 : isSyncA<br>t21 : isSyncA<br>t22 : isSyncA<br>t21 : isSyncA<br>t22 : isSyncA</p>
</blockquote>
<p>(03) 不能被同时访问。因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LockTest3.java的源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : isSyncA"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : isSyncB"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cSyncA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : cSyncA"</span>);</div><div class="line">            &#125; </div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cSyncB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : cSyncB"</span>);</div><div class="line">            &#125; </div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest3</span> </span>&#123;</div><div class="line"></div><div class="line">    Something x = <span class="keyword">new</span> Something();</div><div class="line">    Something y = <span class="keyword">new</span> Something();</div><div class="line"></div><div class="line">    <span class="comment">// 比较(03) x.cSyncA()与y.cSyncB()</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 新建t31, t31会调用 x.isSyncA()</span></div><div class="line">        Thread t31 = <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        x.cSyncA();</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="string">"t31"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 新建t32, t32会调用 x.isSyncB()</span></div><div class="line">        Thread t32 = <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        y.cSyncB();</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="string">"t32"</span>);  </div><div class="line"></div><div class="line"></div><div class="line">        t31.start();  <span class="comment">// 启动t31</span></div><div class="line">        t32.start();  <span class="comment">// 启动t32</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        LockTest3 demo = <span class="keyword">new</span> LockTest3();</div><div class="line"></div><div class="line">        demo.test3();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t31 : cSyncA<br>t31 : cSyncA<br>t31 : cSyncA<br>t31 : cSyncA<br>t31 : cSyncA<br>t32 : cSyncB<br>t32 : cSyncB<br>t32 : cSyncB<br>t32 : cSyncB<br>t32 : cSyncB</p>
</blockquote>
<p>(04) 可以被同时访问。因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LockTest4.java的源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : isSyncA"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : isSyncB"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cSyncA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : cSyncA"</span>);</div><div class="line">            &#125; </div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cSyncB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" : cSyncB"</span>);</div><div class="line">            &#125; </div><div class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest4</span> </span>&#123;</div><div class="line"></div><div class="line">    Something x = <span class="keyword">new</span> Something();</div><div class="line">    Something y = <span class="keyword">new</span> Something();</div><div class="line"></div><div class="line">    <span class="comment">// 比较(04) x.isSyncA()与Something.cSyncA()</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 新建t41, t41会调用 x.isSyncA()</span></div><div class="line">        Thread t41 = <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        x.isSyncA();</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="string">"t41"</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 新建t42, t42会调用 x.isSyncB()</span></div><div class="line">        Thread t42 = <span class="keyword">new</span> Thread(</div><div class="line">                <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        Something.cSyncA();</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="string">"t42"</span>);  </div><div class="line"></div><div class="line"></div><div class="line">        t41.start();  <span class="comment">// 启动t41</span></div><div class="line">        t42.start();  <span class="comment">// 启动t42</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        LockTest4 demo = <span class="keyword">new</span> LockTest4();</div><div class="line"></div><div class="line">        demo.test4();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t41 : isSyncA<br>t42 : cSyncA<br>t41 : isSyncA<br>t42 : cSyncA<br>t41 : isSyncA<br>t42 : cSyncA<br>t41 : isSyncA<br>t42 : cSyncA<br>t41 : isSyncA<br>t42 : cSyncA</p>
</blockquote>
<h4 id="wait-notify-notifyAll-等方法介绍"><a href="#wait-notify-notifyAll-等方法介绍" class="headerlink" title="wait(), notify(), notifyAll()等方法介绍"></a>wait(), notify(), notifyAll()等方法介绍</h4><p>在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。</p>
<p>Object类中关于等待/唤醒的API详细信息如下：<br>notify()<br>– 唤醒在此对象监视器上等待的单个线程。</p>
<p>notifyAll()<br>– 唤醒在此对象监视器上等待的所有线程。</p>
<p>wait()<br>– 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。</p>
<p>wait(long timeout)<br>– 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。</p>
<p>wait(long timeout, int nanos)<br>– 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。</p>
<ol>
<li>wait()和notify()示例</li>
</ol>
<p>下面通过示例演示”wait()和notify()配合使用的情形”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WaitTest.java的源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" call notify()"</span>);</div><div class="line">            <span class="comment">// 唤醒当前的wait线程</span></div><div class="line">            notify();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ThreadA t1 = <span class="keyword">new</span> ThreadA(<span class="string">"t1"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(t1) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 启动“线程t1”</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" start t1"</span>);</div><div class="line">                t1.start();</div><div class="line"></div><div class="line">                <span class="comment">// 主线程等待t1通过notify()唤醒。</span></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" wait()"</span>);</div><div class="line">                t1.wait();</div><div class="line"></div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" continue"</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<blockquote>
<p>main start t1<br>main wait()<br>t1 call notify()<br>main continue</p>
</blockquote>
<p>结果说明：<br>如下图，说明了“主线程”和“线程t1”的流程。</p>
<p><img src="https://sarience.github.io/img/pic/thread_WAN1.png" alt=""></p>
<p>(01) 注意，图中”主线程” 代表“主线程main”。”线程t1” 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。<br>(02) “主线程”通过 new ThreadA(“t1”) 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。<br>(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。<br>(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。<br>(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。</p>
<p>对于上面的代码？曾经有个朋友问到过：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？<br>在解答该问题前，我们先看看jdk文档中关于wait的一段介绍：</p>
<blockquote>
<p>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.<br>In other words, this method behaves exactly as if it simply performs the call wait(0).<br>The current thread must own this object’s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object’s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.</p>
</blockquote>
<p>中文意思大概是：</p>
<blockquote>
<p>引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。<br>“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。</p>
</blockquote>
<p>注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！<br>这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！</p>
<ol>
<li>wait(long timeout)和notify()</li>
</ol>
<p>wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。<br>下面的示例就是演示wait(long timeout)在超时情况下，线程被唤醒的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// WaitTimeoutTest.java的源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" run "</span>);</div><div class="line">        <span class="comment">// 死循环，不断运行。</span></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</div><div class="line">            ;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTimeoutTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ThreadA t1 = <span class="keyword">new</span> ThreadA(<span class="string">"t1"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(t1) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 启动“线程t1”</span></div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" start t1"</span>);</div><div class="line">                t1.start();</div><div class="line"></div><div class="line">                <span class="comment">// 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。</span></div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" call wait "</span>);</div><div class="line">                t1.wait(<span class="number">3000</span>);</div><div class="line"></div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" continue"</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>main start t1<br>main call wait<br>t1 run                  // 大约3秒之后…输出“main continue”<br>main continue</p>
</blockquote>
<p>结果说明：<br>如下图，说明了“主线程”和“线程t1”的流程。<br><img src="https://sarience.github.io/img/pic/thread_WAN2.png" alt=""><br>(01) 注意，图中”主线程” 代表WaitTimeoutTest主线程(即，线程main)。”线程t1” 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。<br>(02) 主线程main执行t1.start()启动“线程t1”。<br>(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。<br>(04) “线程t1”运行之后，进入了死循环，一直不断的运行。<br>(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。</p>
<ol>
<li>wait() 和 notifyAll()<br>通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。<br>下面，我们通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyAllTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ThreadA t1 = <span class="keyword">new</span> ThreadA(<span class="string">"t1"</span>);</div><div class="line">        ThreadA t2 = <span class="keyword">new</span> ThreadA(<span class="string">"t2"</span>);</div><div class="line">        ThreadA t3 = <span class="keyword">new</span> ThreadA(<span class="string">"t3"</span>);</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" sleep(3000)"</span>);</div><div class="line">            Thread.sleep(<span class="number">3000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(obj) &#123;</div><div class="line">            <span class="comment">// 主线程等待唤醒。</span></div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" notifyAll()"</span>);</div><div class="line">            obj.notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span></span>&#123;</div><div class="line">            <span class="keyword">super</span>(name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (obj) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">// 打印输出结果</span></div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" wait"</span>);</div><div class="line"></div><div class="line">                    <span class="comment">// 唤醒当前的wait线程</span></div><div class="line">                    obj.wait();</div><div class="line"></div><div class="line">                    <span class="comment">// 打印输出结果</span></div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" continue"</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t1 wait<br>main sleep(3000)<br>t3 wait<br>t2 wait<br>main notifyAll()<br>t2 continue<br>t3 continue<br>t1 continue</p>
</blockquote>
<p>结果说明：<br>参考下面的流程图。 </p>
<p><img src="https://sarience.github.io/img/pic/thread_WAN3.png" alt=""></p>
<p>(01) 主线程中新建并且启动了3个线程”t1”, “t2”和”t3”。<br>(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设”t1”, “t2”和”t3”这3个线程都运行了。以”t1”为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，”t2”和”t3”也会等待其它线程通过nofity()或nofityAll()来唤醒它们。<br>(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒”t1”, “t2”和”t3”这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，”t1”, “t2”和”t3”就可以获取“obj锁”而继续运行了！</p>
<ol>
<li>为什么notify(), wait()等函数定义在Object中，而不是Thread中</li>
</ol>
<p>Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。</p>
<p>wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！<br>OK，线程调用wait()之后，会释放它锁持有的“同步锁”；而且，根据前面的介绍，我们知道：等待线程可以被notify()或notifyAll()唤醒。现在，请思考一个问题：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。</p>
<p>负责唤醒等待线程的那个线程(我们称为“唤醒线程”)，它只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。</p>
<p>总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。</p>
<h4 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h4><ol>
<li>yield()介绍<br>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！</li>
</ol>
<ol>
<li>yield()示例<br>下面，通过示例查看它的用法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// YieldTest.java的源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span></span>&#123; </div><div class="line">        <span class="keyword">super</span>(name); </div><div class="line">    &#125; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123; </div><div class="line">            System.out.printf(<span class="string">"%s [%d]:%d\n"</span>, <span class="keyword">this</span>.getName(), <span class="keyword">this</span>.getPriority(), i); </div><div class="line">            <span class="comment">// i整除4时，调用yield</span></div><div class="line">            <span class="keyword">if</span> (i%<span class="number">4</span> == <span class="number">0</span>)</div><div class="line">                Thread.yield();</div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldTest</span></span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </div><div class="line">        ThreadA t1 = <span class="keyword">new</span> ThreadA(<span class="string">"t1"</span>); </div><div class="line">        ThreadA t2 = <span class="keyword">new</span> ThreadA(<span class="string">"t2"</span>); </div><div class="line">        t1.start(); </div><div class="line">        t2.start();</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(某一次的)运行结果:</p>
<blockquote>
<p>t1 [5]:0<br>t2 [5]:0<br>t1 [5]:1<br>t1 [5]:2<br>t1 [5]:3<br>t1 [5]:4<br>t1 [5]:5<br>t1 [5]:6<br>t1 [5]:7<br>t1 [5]:8<br>t1 [5]:9<br>t2 [5]:1<br>t2 [5]:2<br>t2 [5]:3<br>t2 [5]:4<br>t2 [5]:5<br>t2 [5]:6<br>t2 [5]:7<br>t2 [5]:8<br>t2 [5]:9</p>
</blockquote>
<p>结果说明：<br>“线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。</p>
<ol>
<li>yield() 与 wait()的比较</li>
</ol>
<p>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：<br>(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。<br>(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</p>
<p>下面通过示例演示yield()是不会释放锁的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// YieldLockTest.java 的源码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldLockTest</span></span>&#123; </div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </div><div class="line">        ThreadA t1 = <span class="keyword">new</span> ThreadA(<span class="string">"t1"</span>); </div><div class="line">        ThreadA t2 = <span class="keyword">new</span> ThreadA(<span class="string">"t2"</span>); </div><div class="line">        t1.start(); </div><div class="line">        t2.start();</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span></span>&#123; </div><div class="line">            <span class="keyword">super</span>(name); </div><div class="line">        &#125; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; </div><div class="line">            <span class="comment">// 获取obj对象的同步锁</span></div><div class="line">            <span class="keyword">synchronized</span> (obj) &#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123; </div><div class="line">                    System.out.printf(<span class="string">"%s [%d]:%d\n"</span>, <span class="keyword">this</span>.getName(), <span class="keyword">this</span>.getPriority(), i); </div><div class="line">                    <span class="comment">// i整除4时，调用yield</span></div><div class="line">                    <span class="keyword">if</span> (i%<span class="number">4</span> == <span class="number">0</span>)</div><div class="line">                        Thread.yield();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(某一次)运行结果：</p>
<blockquote>
<p>t1 [5]:0<br>t1 [5]:1<br>t1 [5]:2<br>t1 [5]:3<br>t1 [5]:4<br>t1 [5]:5<br>t1 [5]:6<br>t1 [5]:7<br>t1 [5]:8<br>t1 [5]:9<br>t2 [5]:0<br>t2 [5]:1<br>t2 [5]:2<br>t2 [5]:3<br>t2 [5]:4<br>t2 [5]:5<br>t2 [5]:6<br>t2 [5]:7<br>t2 [5]:8<br>t2 [5]:9</p>
</blockquote>
<p>结果说明：<br>主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！</p>
<h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><ol>
<li><p>sleep()介绍<br>sleep() 定义在Thread.java中。<br>sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。</p>
</li>
<li><p>sleep()示例<br>下面通过一个简单示例演示sleep()的用法。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SleepTest.java的源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span></span>&#123; </div><div class="line">        <span class="keyword">super</span>(name); </div><div class="line">    &#125; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123; </div><div class="line">                System.out.printf(<span class="string">"%s: %d\n"</span>, <span class="keyword">this</span>.getName(), i); </div><div class="line">                <span class="comment">// i能被4整除时，休眠100毫秒</span></div><div class="line">                <span class="keyword">if</span> (i%<span class="number">4</span> == <span class="number">0</span>)</div><div class="line">                    Thread.sleep(<span class="number">100</span>);</div><div class="line">            &#125; </div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepTest</span></span>&#123; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </div><div class="line">        ThreadA t1 = <span class="keyword">new</span> ThreadA(<span class="string">"t1"</span>); </div><div class="line">        t1.start(); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t1: 0<br>t1: 1<br>t1: 2<br>t1: 3<br>t1: 4<br>t1: 5<br>t1: 6<br>t1: 7<br>t1: 8<br>t1: 9</p>
</blockquote>
<p>结果说明：<br>程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。</p>
<ol>
<li>sleep() 与 wait()的比较<br>我们知道，wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。<br>但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。<br>下面通过示例演示sleep()是不会释放锁的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// SleepLockTest.java的源码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepLockTest</span></span>&#123; </div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </div><div class="line">        ThreadA t1 = <span class="keyword">new</span> ThreadA(<span class="string">"t1"</span>); </div><div class="line">        ThreadA t2 = <span class="keyword">new</span> ThreadA(<span class="string">"t2"</span>); </div><div class="line">        t1.start(); </div><div class="line">        t2.start();</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span></span>&#123; </div><div class="line">            <span class="keyword">super</span>(name); </div><div class="line">        &#125; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; </div><div class="line">            <span class="comment">// 获取obj对象的同步锁</span></div><div class="line">            <span class="keyword">synchronized</span> (obj) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123; </div><div class="line">                        System.out.printf(<span class="string">"%s: %d\n"</span>, <span class="keyword">this</span>.getName(), i); </div><div class="line">                        <span class="comment">// i能被4整除时，休眠100毫秒</span></div><div class="line">                        <span class="keyword">if</span> (i%<span class="number">4</span> == <span class="number">0</span>)</div><div class="line">                            Thread.sleep(<span class="number">100</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t1: 0<br>t1: 1<br>t1: 2<br>t1: 3<br>t1: 4<br>t1: 5<br>t1: 6<br>t1: 7<br>t1: 8<br>t1: 9<br>t2: 0<br>t2: 1<br>t2: 2<br>t2: 3<br>t2: 4<br>t2: 5<br>t2: 6<br>t2: 7<br>t2: 8<br>t2: 9</p>
</blockquote>
<p>结果说明：<br>主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！<br>注意，若我们注释掉synchronized (obj)后再次执行该程序，t1和t2是可以相互切换的。下面是注释调synchronized(obj) 之后的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// SleepLockTest.java的源码(注释掉synchronized(obj))</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepLockTest</span></span>&#123; </div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </div><div class="line">        ThreadA t1 = <span class="keyword">new</span> ThreadA(<span class="string">"t1"</span>); </div><div class="line">        ThreadA t2 = <span class="keyword">new</span> ThreadA(<span class="string">"t2"</span>); </div><div class="line">        t1.start(); </div><div class="line">        t2.start();</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span></span>&#123; </div><div class="line">            <span class="keyword">super</span>(name); </div><div class="line">        &#125; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; </div><div class="line">            <span class="comment">// 获取obj对象的同步锁</span></div><div class="line"><span class="comment">//            synchronized (obj) &#123;</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">10</span>; i++)&#123; </div><div class="line">                        System.out.printf(<span class="string">"%s: %d\n"</span>, <span class="keyword">this</span>.getName(), i); </div><div class="line">                        <span class="comment">// i能被4整除时，休眠100毫秒</span></div><div class="line">                        <span class="keyword">if</span> (i%<span class="number">4</span> == <span class="number">0</span>)</div><div class="line">                            Thread.sleep(<span class="number">100</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line"><span class="comment">//            &#125;</span></div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><ol>
<li>join()介绍<br>join() 定义在Thread.java中。<br>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。这句话可能有点晦涩，我们还是通过例子去理解：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 主线程</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Son s = <span class="keyword">new</span> Son();</div><div class="line">        s.start();</div><div class="line">        s.join();</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 子线程</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：<br>上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。<br>在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！</p>
<ol>
<li>join()源码分析(基于JDK1.7.0_40)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    join(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></div><div class="line"><span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</div><div class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (isAlive()) &#123;</div><div class="line">            wait(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">while</span> (isAlive()) &#123;</div><div class="line">            <span class="keyword">long</span> delay = millis - now;</div><div class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            wait(delay);</div><div class="line">            now = System.currentTimeMillis() - base;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：<br>从代码中，我们可以发现。当millis==0时，会进入while(isAlive())循环；即只要子线程是活的，主线程就不停的等待。<br>我们根据上面解释join()作用时的代码来理解join()的用法！<br>问题：<br>虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让”子线程等待才对(因为调用子线程对象s的wait方法嘛)”？<br>答案：wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！</p>
<ol>
<li>join()示例</li>
</ol>
<p>在理解join()的作用之后，接下来通过示例查看join()的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JoinTest.java的源码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span></span>&#123; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ThreadA t1 = <span class="keyword">new</span> ThreadA(<span class="string">"t1"</span>); <span class="comment">// 新建“线程t1”</span></div><div class="line"></div><div class="line">            t1.start();                     <span class="comment">// 启动“线程t1”</span></div><div class="line">            t1.join();                        <span class="comment">// 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成”</span></div><div class="line">            System.out.printf(<span class="string">"%s finish\n"</span>, Thread.currentThread().getName()); </div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String name)</span></span>&#123; </div><div class="line">            <span class="keyword">super</span>(name); </div><div class="line">        &#125; </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123; </div><div class="line">            System.out.printf(<span class="string">"%s start\n"</span>, <span class="keyword">this</span>.getName()); </div><div class="line"></div><div class="line">            <span class="comment">// 延时操作</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;<span class="number">1000000</span>; i++)</div><div class="line">               ;</div><div class="line"></div><div class="line">            System.out.printf(<span class="string">"%s finish\n"</span>, <span class="keyword">this</span>.getName()); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p>t1 start<br>t1 finish<br>main finish<br>结果说明：<br>运行流程如图<br>(01) 在“主线程main”中通过 new ThreadA(“t1”) 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。<br>(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。</p>
<p><img src="https://sarience.github.io/img/pic/thread_join.jpg" alt=""></p>
<h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><ol>
<li>interrupt()说明<br>在介绍终止线程的方式之前，有必要先对interrupt()进行了解。<br>关于interrupt()，java的djk文档描述如下：<a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/api/</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Interrupts <span class="keyword">this</span> thread.</div><div class="line">Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of <span class="keyword">this</span> thread is invoked, which may cause a SecurityException to be thrown.</div><div class="line"></div><div class="line"><span class="function">If <span class="keyword">this</span> thread is blocked in an invocation of the <span class="title">wait</span><span class="params">()</span>, <span class="title">wait</span><span class="params">(<span class="keyword">long</span>)</span>, or <span class="title">wait</span><span class="params">(<span class="keyword">long</span>, <span class="keyword">int</span>)</span> methods of the Object class, or of the <span class="title">join</span><span class="params">()</span>, <span class="title">join</span><span class="params">(<span class="keyword">long</span>)</span>, <span class="title">join</span><span class="params">(<span class="keyword">long</span>, <span class="keyword">int</span>)</span>, <span class="title">sleep</span><span class="params">(<span class="keyword">long</span>)</span>, or <span class="title">sleep</span><span class="params">(<span class="keyword">long</span>, <span class="keyword">int</span>)</span>, methods of <span class="keyword">this</span> class, then its interrupt status will be cleared and it will receive an InterruptedException.</span></div><div class="line"></div><div class="line">If <span class="keyword">this</span> thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a ClosedByInterruptException.</div><div class="line"></div><div class="line">If <span class="keyword">this</span> thread is blocked in a Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as <span class="keyword">if</span> the selector's wakeup method were invoked.</div><div class="line"></div><div class="line">If none of the previous conditions hold then <span class="keyword">this</span> thread's interrupt status will be set.</div><div class="line"></div><div class="line">Interrupting a thread that is not alive need not have any effect.</div></pre></td></tr></table></figure>
<p>大致意思是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">interrupt()的作用是中断本线程。</div><div class="line">本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。</div><div class="line">如果本线程是处于阻塞状态：调用线程的wait(), wait(<span class="keyword">long</span>)或wait(<span class="keyword">long</span>, <span class="keyword">int</span>)会让它进入等待(阻塞)状态，或者调用线程的join(), join(<span class="keyword">long</span>), join(<span class="keyword">long</span>, <span class="keyword">int</span>), sleep(<span class="keyword">long</span>), sleep(<span class="keyword">long</span>, <span class="keyword">int</span>)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“<span class="keyword">true</span>”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“<span class="keyword">false</span>”，同时，会产生一个InterruptedException的异常。</div><div class="line">如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为<span class="keyword">true</span>，并且它会立即从选择操作中返回。</div><div class="line">如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“<span class="keyword">true</span>”。</div><div class="line">中断一个“已终止的线程”不会产生任何操作。</div></pre></td></tr></table></figure>
<ol>
<li><p>终止线程的方式<br>Thread中的stop()和suspend()方法，由于固有的不安全性，已经建议不再使用！<br>下面，我先分别讨论线程在“阻塞状态”和“运行状态”的终止方式，然后再总结出一个通用的方式。</p>
<p> 1 终止处于“阻塞状态”的线程<br>通常，我们通过“中断”方式终止处于“阻塞状态”的线程。<br>当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程，形式如下：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">// 执行任务...</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        <span class="comment">// 由于产生InterruptedException异常，退出while(true)循环，线程终止！</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！<br>注意：对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 执行任务...</span></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">            <span class="comment">// InterruptedException在while(true)循环体内。</span></div><div class="line">            <span class="comment">// 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。</p>
<ol>
<li>终止处于“运行状态”的线程<br>通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“中断标记”和“额外添加标记”。<br>(01) 通过“中断标记”终止线程。<br>形式如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (!isInterrupted()) &#123;</div><div class="line">        <span class="comment">// 执行任务...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>说明：isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。<br>注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。</p>
<p>(02) 通过“额外添加标记”。<br>形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag= <span class="keyword">true</span>;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stopTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    flag = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (flag) &#123;</div><div class="line">        <span class="comment">// 执行任务...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。<br>注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。</p>
<p>综合线程处于“阻塞状态”和“运行状态”的终止方式，比较通用的终止线程的形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 1. isInterrupted()保证，只要中断标记为true就终止线程。</span></div><div class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</div><div class="line">            <span class="comment">// 执行任务...</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">        <span class="comment">// 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>终止线程的示例</li>
</ol>
<p>interrupt()常常被用来终止“阻塞状态”线程。参考下面示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// Demo1.java的源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span> (!isInterrupted()) &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                i++;</div><div class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">" ("</span>+<span class="keyword">this</span>.getState()+<span class="string">") loop "</span> + i);  </div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            System.out.println(Thread.currentThread().getName() +<span class="string">" ("</span>+<span class="keyword">this</span>.getState()+<span class="string">") catch InterruptedException."</span>);  </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            Thread t1 = <span class="keyword">new</span> MyThread(<span class="string">"t1"</span>);  <span class="comment">// 新建“线程t1”</span></div><div class="line">            System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is new."</span>);  </div><div class="line"></div><div class="line">            t1.start();                      <span class="comment">// 启动“线程t1”</span></div><div class="line">            System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is started."</span>);  </div><div class="line"></div><div class="line">            <span class="comment">// 主线程休眠300ms，然后主线程给t1发“中断”指令。</span></div><div class="line">            Thread.sleep(<span class="number">300</span>);</div><div class="line">            t1.interrupt();</div><div class="line">            System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is interrupted."</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 主线程休眠300ms，然后查看t1的状态。</span></div><div class="line">            Thread.sleep(<span class="number">300</span>);</div><div class="line">            System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is interrupted now."</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t1 (NEW) is new.<br>t1 (RUNNABLE) is started.<br>t1 (RUNNABLE) loop 1<br>t1 (RUNNABLE) loop 2<br>t1 (TIMED_WAITING) is interrupted.<br>t1 (RUNNABLE) catch InterruptedException.<br>t1 (TERMINATED) is interrupted now.</p>
</blockquote>
<p>结果说明：<br>(01) 主线程main中通过new MyThread(“t1”)创建线程t1，之后通过t1.start()启动线程t1。<br>(02) t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。<br>(03) t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。</p>
<p>我们对上面的结果进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// Demo2.java的源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">" ("</span>+<span class="keyword">this</span>.getState()+<span class="string">") catch InterruptedException."</span>);  </div><div class="line">            &#125;</div><div class="line">            i++;</div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" ("</span>+<span class="keyword">this</span>.getState()+<span class="string">") loop "</span> + i);  </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            Thread t1 = <span class="keyword">new</span> MyThread(<span class="string">"t1"</span>);  <span class="comment">// 新建“线程t1”</span></div><div class="line">            System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is new."</span>);  </div><div class="line"></div><div class="line">            t1.start();                      <span class="comment">// 启动“线程t1”</span></div><div class="line">            System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is started."</span>);  </div><div class="line"></div><div class="line">            <span class="comment">// 主线程休眠300ms，然后主线程给t1发“中断”指令。</span></div><div class="line">            Thread.sleep(<span class="number">300</span>);</div><div class="line">            t1.interrupt();</div><div class="line">            System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is interrupted."</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 主线程休眠300ms，然后查看t1的状态。</span></div><div class="line">            Thread.sleep(<span class="number">300</span>);</div><div class="line">            System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is interrupted now."</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t1 (NEW) is new.<br>t1 (RUNNABLE) is started.<br>t1 (RUNNABLE) loop 1<br>t1 (RUNNABLE) loop 2<br>t1 (TIMED_WAITING) is interrupted.<br>t1 (RUNNABLE) catch InterruptedException.<br>t1 (RUNNABLE) loop 3<br>t1 (RUNNABLE) loop 4<br>t1 (RUNNABLE) loop 5<br>t1 (TIMED_WAITING) is interrupted now.<br>t1 (RUNNABLE) loop 6<br>t1 (RUNNABLE) loop 7<br>t1 (RUNNABLE) loop 8<br>t1 (RUNNABLE) loop 9<br>…</p>
</blockquote>
<p>结果说明：<br>程序进入了死循环！<br>为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记[即isInterrupted()会返回false]，而且会抛出InterruptedException异常[该异常在while循环体内被捕获]。因此，t1理所当然的会进入死循环了。<br>解决该问题，需要我们在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。</p>
<p>下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// Demo3.java的源码</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag= <span class="keyword">true</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopTask</span><span class="params">()</span> </span>&#123;</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">                <span class="keyword">while</span> (flag) &#123;</div><div class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></div><div class="line">                    i++;</div><div class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" ("</span>+<span class="keyword">this</span>.getState()+<span class="string">") loop "</span> + i);  </div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </div><div class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">" ("</span>+<span class="keyword">this</span>.getState()+<span class="string">") catch InterruptedException."</span>);  </div><div class="line">            &#125;</div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">"t1"</span>);  <span class="comment">// 新建“线程t1”</span></div><div class="line">            System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is new."</span>);  </div><div class="line"></div><div class="line">            t1.start();                      <span class="comment">// 启动“线程t1”</span></div><div class="line">            System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is started."</span>);  </div><div class="line"></div><div class="line">            <span class="comment">// 主线程休眠300ms，然后主线程给t1发“中断”指令。</span></div><div class="line">            Thread.sleep(<span class="number">300</span>);</div><div class="line">            t1.stopTask();</div><div class="line">            System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is interrupted."</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 主线程休眠300ms，然后查看t1的状态。</span></div><div class="line">            Thread.sleep(<span class="number">300</span>);</div><div class="line">            System.out.println(t1.getName() +<span class="string">" ("</span>+t1.getState()+<span class="string">") is interrupted now."</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>t1 (NEW) is new.<br>t1 (RUNNABLE) is started.<br>t1 (RUNNABLE) loop 1<br>t1 (RUNNABLE) loop 2<br>t1 (TIMED_WAITING) is interrupted.<br>t1 (RUNNABLE) loop 3<br>t1 (TERMINATED) is interrupted now.</p>
</blockquote>
<ol>
<li>interrupted() 和 isInterrupted()的区别</li>
</ol>
<p>最后谈谈 interrupted() 和 isInterrupted()。<br>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。<br>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。</p>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java异常]]></title>
      <url>/2017/05/04/Java%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<p>Java异常简介</p>
<p>　　Java异常是Java提供的一种识别及响应错误的一致性机制。<br>　　Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪“抛出，异常信息回答了“为什么“会抛出。</p>
<p>Java异常机制用到的几个关键字：try、catch、finally、throw、throws。<br>• try        – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。<br>• catch   – 用于捕获异常。catch用来捕获try语句块中发生的异常。<br>• finally  – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。<br>• throw   – 用于抛出异常。<br>• throws – 用在方法签名中，用于声明该方法可能抛出的异常。</p>
<p>下面通过几个示例对这几个关键字进行简单了解。</p>
<p>示例一: 了解try和catch基本用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</div><div class="line">              System.out.println(<span class="string">"i="</span>+i); </div><div class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</div><div class="line">              System.out.println(<span class="string">"Caught Exception"</span>); </div><div class="line">            System.out.println(<span class="string">"e.getMessage(): "</span> + e.getMessage()); </div><div class="line">            System.out.println(<span class="string">"e.toString(): "</span> + e.toString()); </div><div class="line">            System.out.println(<span class="string">"e.printStackTrace():"</span>);</div><div class="line">            e.printStackTrace(); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>Caught Exception<br>e.getMessage(): / by zero<br>e.toString(): java.lang.ArithmeticException: / by zero<br>e.printStackTrace():<br>java.lang.ArithmeticException: / by zero<br>    at Demo1.main(Demo1.java:6)<br>结果说明：在try语句块中有除数为0的操作，该操作会抛出java.lang.ArithmeticException异常。通过catch，对该异常进行捕获。<br>观察结果我们发现，并没有执行System.out.println(“i=”+i)。这说明try语句块发生异常之后，try语句块中的剩余内容就不会再被执行了。</p>
</blockquote>
<p>示例二: 了解finally的基本用法</p>
<p>在”示例一”的基础上，我们添加finally语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</div><div class="line">              System.out.println(<span class="string">"i="</span>+i); </div><div class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</div><div class="line">              System.out.println(<span class="string">"Caught Exception"</span>); </div><div class="line">            System.out.println(<span class="string">"e.getMessage(): "</span> + e.getMessage()); </div><div class="line">            System.out.println(<span class="string">"e.toString(): "</span> + e.toString()); </div><div class="line">            System.out.println(<span class="string">"e.printStackTrace():"</span>);</div><div class="line">            e.printStackTrace(); </div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            System.out.println(<span class="string">"run finally"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>Caught Exception<br>e.getMessage(): / by zero<br>e.toString(): java.lang.ArithmeticException: / by zero<br>e.printStackTrace():<br>java.lang.ArithmeticException: / by zero<br>    at Demo2.main(Demo2.java:6)<br>run finally</p>
</blockquote>
<p>结果说明：最终执行了finally语句块。</p>
<p>示例三: 了解throws和throw的基本用法</p>
<p>throws是用于声明抛出的异常，而throw是用于抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            test();</div><div class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</div><div class="line">            System.out.println(<span class="string">"Catch My Exception"</span>);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> MyException</span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>;</div><div class="line">              System.out.println(<span class="string">"i="</span>+i); </div><div class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"This is MyException"</span>); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>Catch My Exception<br>MyException: This is MyException<br>    at Demo3.test(Demo3.java:24)<br>    at Demo3.main(Demo3.java:13)</p>
</blockquote>
<p>结果说明：<br>　　MyException是继承于Exception的子类。test()的try语句块中产生ArithmeticException异常(除数为0)，并在catch中捕获该异常；接着抛出MyException异常。main()方法对test()中抛出的MyException进行捕获处理。</p>
<p>Java异常框架</p>
<p>Java异常架构图</p>
<ol>
<li><p>Throwable<br>　　Throwable是 Java 语言中所有错误或异常的超类。<br>　　Throwable包含两个子类: Error 和 Exception。它们通常用于指示发生了异常情况。<br>　　Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。</p>
</li>
<li><p>Exception<br>　　Exception及其子类是 Throwable 的一种形式，它指出了合理的应用程序想要捕获的条件。</p>
</li>
<li><p>RuntimeException<br>　　RuntimeException是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。<br>　　编译器不会检查RuntimeException异常。例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既”没有通过throws声明抛出ArithmeticException异常”，也”没有通过try…catch…处理该异常”，也能通过编译。这就是我们所说的”编译器不会检查RuntimeException异常”！<br>　　如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p>
</li>
<li><p>Error<br>　　和Exception一样，Error也是Throwable的子类。它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。<br>　　和RuntimeException一样，编译器也不会检查Error。</p>
</li>
</ol>
<p>Java将可抛出(Throwable)的结构分为三种类型：被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。</p>
<p>(01) 运行时异常<br>定义: RuntimeException及其子类都被称为运行时异常。<br>特点: Java编译器不会检查它。也就是说，当程序中可能出现这类异常时，倘若既”没有通过throws声明抛出它”，也”没有用try-catch语句捕获它”，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。<br>　　虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。<br>　　如果产生运行时异常，则需要通过修改代码来进行避免。例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！</p>
<p>(02) 被检查的异常<br>定义: Exception类本身，以及Exception的子类中除了”运行时异常”之外的其它子类都属于被检查异常。<br>特点: Java编译器会检查它。此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。<br>　　被检查异常通常都是可以恢复的。</p>
<p>(03) 错误<br>定义: Error类及其子类。<br>特点: 和运行时异常一样，编译器也不会对错误进行检查。<br>　　当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。<br>　　按照Java惯例，我们是不应该是实现任何新的Error子类的！</p>
<p>对于上面的3种结构，我们在抛出异常或错误时，到底该哪一种？《Effective Java》中给出的建议是：对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。</p>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java的自动拆箱与装箱]]></title>
      <url>/2017/05/03/Java%E7%9A%84%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E4%B8%8E%E8%A3%85%E7%AE%B1/</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Integer i1 = <span class="number">100</span>;</div><div class="line">        Integer i2 = <span class="number">100</span>;</div><div class="line">        Integer i3 = <span class="number">200</span>;</div><div class="line">        Integer i4 = <span class="number">200</span>;</div><div class="line"></div><div class="line">        System.out.println(i1==i2);  <span class="comment">//true</span></div><div class="line">        System.out.println(i3==i4);  <span class="comment">//false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码的后面，我们可以看到它们的执行结果是不一样的，为什么，在看看我们上面的说明。<br>1、i1和i2会进行自动装箱，执行了valueOf函数，它们的值在(-128,128]这个范围内，它们会拿到SMALL_VALUES数组里面的同一个对象SMALL_VALUES[228]，它们引用到了同一个Integer对象，所以它们肯定是相等的。</p>
<p>2、i3和i4也会进行自动装箱，执行了valueOf函数，它们的值大于128，所以会执行new Integer(200)，也就是说它们会分别创建两个不同的对象，所以它们肯定不等。</p>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java实例变量与类变量]]></title>
      <url>/2017/05/03/Java%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E4%B8%8E%E7%B1%BB%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<p>此文只是个人的查漏补缺，不会很全面地去解析，所以想要系统学习的童鞋请移步疯狂java讲义一书或其他博客吧，就酱&lt;(￣︶￣)&gt;～</p>
<h4 id="实例变量与类变量"><a href="#实例变量与类变量" class="headerlink" title="实例变量与类变量"></a>实例变量与类变量</h4><p>实例变量：在类体内没有用static修饰的成员变量，又称非静态变量。<br>类变量：在类体内用static修饰的成员变量，又称静态变量。</p>
<ol>
<li>实例变量初始化时机<br>除了静态方法-&gt;代码块—&gt;构造方法的顺序，对实例变量初始化还有个顺序：赋值语句保持在源代码中的顺序，如下两段代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.douya.day9;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by douya on 17-5-3.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FiledInitial</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">20</span>;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            count = <span class="number">30</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Exam</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"count:"</span> + count);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Exam();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>count:30</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.douya.day9;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by douya on 17-5-3.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FiledInitial</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Exam</span> </span>&#123;</div><div class="line">        &#123;</div><div class="line">            count = <span class="number">30</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> count = <span class="number">20</span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Exam</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"count:"</span> + count);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Exam();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>count:20</p>
</blockquote>
<ol>
<li>类变量的初始化时机<br>与实例变量一致，遵循源码中的顺序，但是为了更加了解static的机制，我们看看下面这段代码和执行结果：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.douya.day9;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by douya on 17-5-3.</div><div class="line"> */</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Price</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Price INSTANCE = <span class="keyword">new</span> Price(<span class="number">2.8</span>);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">double</span> initPrice = <span class="number">20</span>;</div><div class="line"></div><div class="line">    <span class="keyword">double</span> currentPrice;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Price</span><span class="params">(<span class="keyword">double</span> discount)</span> </span>&#123;</div><div class="line">        currentPrice = initPrice - discount;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticPrice</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(Price.INSTANCE.currentPrice);</div><div class="line"></div><div class="line">        Price price = <span class="keyword">new</span> Price(<span class="number">2.8</span>);</div><div class="line">        System.out.println(price.currentPrice);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>-2.8<br>17.2</p>
</blockquote>
<p>这段代码，从表面上看，结果应该输出两个17.2才对，实际输出却是-2.8,17.2<br>让我们来分析一下 代码的执行过程：</p>
<ol>
<li>第一次用到Price这个类时，程序对Price进行初始化，初始化分两个阶段：第一个阶段，为类变量分配内存空间；第二阶段，初始化代码顺序和为变量赋值；</li>
<li>这样就很好理解了，第一阶段的时候，系统为INSTANCE,initPrice两个类变量分配内存空间，此时INSTANCE,initPrice的值默认为null，0；</li>
<li>接着进入第二阶段，为INSTANCE,initPrice赋值，为INSTANCE赋值时，调用Price(2.8)，创建Price实例，并立即为currentPrice赋值，而此时的initPrice值为0，所以计算出的currentPrice为-2,8。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java数组补缺]]></title>
      <url>/2017/05/03/Java%E6%95%B0%E7%BB%84%E8%A1%A5%E7%BC%BA/</url>
      <content type="html"><![CDATA[<p>此文只是个人的查漏补缺，不会很全面地去解析，所以想要系统学习的童鞋请移步疯狂java讲义一书或其他博客吧，就酱&lt;(￣︶￣)&gt;～</p>
<h4 id="数组的静态初始化与动态初始化"><a href="#数组的静态初始化与动态初始化" class="headerlink" title="数组的静态初始化与动态初始化"></a>数组的静态初始化与动态初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//静态初始化</span></div><div class="line">String[] s1 = <span class="keyword">new</span> String[]&#123;<span class="string">"you"</span>, <span class="string">"can"</span>, <span class="string">"see"</span>&#125;;</div><div class="line"><span class="comment">//静态初始化</span></div><div class="line">String[] s2 = &#123;<span class="string">"as"</span>, <span class="string">"i"</span>, <span class="string">"said"</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">//动态初始化</span></div><div class="line">String[] s3 = <span class="keyword">new</span> String[<span class="number">5</span>];</div></pre></td></tr></table></figure>
<ol>
<li><p>数组元素初始化的值<br>如下图啦：<br><img src="http://sarience.github.io/img/pic/ArrayInitial_val.png" alt=""><br>Tips:不能同时使用动态初始化和静态初始化，反正你用了编译器也不会让你通过╮（￣▽￣）╭<br><img src="http://sarience.github.io/img/pic/ArrayInitial.png" alt=""></p>
</li>
<li><p>数组一定得初始化吗？<br>不一定，当数组变量指向一个已经存在的数组就可以啦(本质是引用变量不需要初始化，而对象本身才需要初始化)</p>
</li>
<li><p>变量在栈中，对象在堆中<br>一般来说，所有的局部变量都是放在栈中保存的，包括基本类型的变量和引用类型的变量，都存储在各自的方法栈区中；引用类型的变量所引用的对象则总是在堆中。</p>
</li>
<li><p>数组每个元素都应当做引用类型的变量<br>Java中多维数组本质是一维数组每个元素都指向另一个一维数组，依次递归下去。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中Collection与Map详解]]></title>
      <url>/2017/05/02/Java%E4%B8%ADCollection%E4%B8%8EMap%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java  SDK不提供直接继承自Collection的类，Java  SDK提供的类都是继承自Collection的“子接口”如List和Set。</p>
<p>所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后一个构造函数允许用户复制一个Collection。</p>
<p>如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Iterator  it  =  collection.iterator();  <span class="comment">//  获得一个迭代子 </span></div><div class="line"><span class="keyword">while</span>(it.hasNext())  &#123; </div><div class="line">Object  obj  =  it.next();  <span class="comment">//  得到下一个元素 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由Collection接口派生的两个接口是List和Set。 </p>
<h4 id="1-List接口"><a href="#1-List接口" class="headerlink" title="1. List接口"></a>1. List接口</h4><p>List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。和下面要提到的Set不同，List允许有相同的元素。</p>
<p>除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。<br>实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。 </p>
<ol>
<li><p>LinkedList类</p>
<p> LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p>
<p> 注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List  list  =  Collections.synchronizedList(<span class="keyword">new</span>  LinkedList(...));</div></pre></td></tr></table></figure>
</li>
<li><p>ArrayList类</p>
<p> ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。</p>
<p> size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。</p>
<p> 每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。 和LinkedList一样，ArrayList也是非同步的（unsynchronized）。 </p>
<ol>
<li><p>Vector类</p>
<p>Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。 </p>
</li>
<li><p>Stack 类</p>
<p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 </p>
</li>
</ol>
</li>
</ol>
<h4 id="2-Set接口"><a href="#2-Set接口" class="headerlink" title="2. Set接口"></a>2. Set接口</h4><p>Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。<br>很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。<br>请注意：必须小心操作可变对象（Mutable  Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。</p>
<ol>
<li><p>HashSet<br> 按照哈希算法来存取集合中的对象，存取速度比较快。当向集合中加入一个对象时，HashSet会调用对象的hashCode()<br> 方法来获得哈希码，然后根据这个哈希码进一步计算出对象在集合中的存放位置。</p>
<ol>
<li><p>哈希表与哈希方法<br> 哈希方法在“键- 值对”的存储位置与它的键之间建立一个确定的对应函数关系 hash() ，使得每一个键与结构中的一个唯一的存储位置相对应：</p>
</li>
<li><p>存储位置=hash( 键 )<br> 举一个例子，有一组“键值对”：<5, ”="" tom="">、 <8, ”="" jane="">、 <12, ”="" bit="">、 <17, ”="" lily="">、 <20, ”="" sunny="">，我们按照如下哈希函数对键进行计算 :hash(x)=x%17+3 ，得出如下结果： hash(5)=8 、 hash(8)=11 、 hash(12)=15 、 hash(17)=3 、 hash(20)=6 。我们把 <5, ”="" tom="">、 <8, ”="" jane="">、 <12, ”="" bit="">、 <17, ”="" lily="">、 <20, ”="" sunny="">分别放到地址为 8 、 11 、 15 、 3 、 6 的位置上。当要检索 17 对应的值的时候，只要首先计算 17 的哈希值为 3 ，然后到地址为 3 的地方去取数据就可以找到 17 对应的数据是“ Lily”了，可见检索速度是非常快的。</20,></17,></12,></8,></5,></20,></17,></12,></8,></5,></p>
</li>
<li><p>冲突与冲突的解决<br> 通常键的取值范围比哈希表地址集合大很多，因此有可能经过同一哈希函数的计算，把不同的键映射到了同一个地址上面，这就叫冲突。比如，有一组“键- 值对”，其键分别为 12361 、 7251 、 3309 、 30976 ，采用的哈希函数是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</div><div class="line">			<span class="keyword">return</span> key%<span class="number">73</span>+<span class="number">13420</span>;</div><div class="line">		   &#125;</div></pre></td></tr></table></figure>
<p> 则将会得到hash(12361)=hash(7251)=hash(3309)=hash(30976)=13444 ，即不同的键通过哈希函数对应到了同一个地址，我们称这种哈希计算结果相同的不同键为同义词。此时再换用另一种哈希函数计算.换言之,当存在多个键通过哈希计算结果相同时,会再选用另一个哈希计算直到不存在重复地址为止.</p>
<p> 我们还应该注意，Java语言对equals()的要求如下，这些要求是必须遵循的：<br> ? 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。<br> ? 反射性：x.equals(x)必须返回是“true”。<br> ? 类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。<br> ? 还有一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。<br> ? 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。<br> 以上这五点是重写equals()方法时，必须遵守的准则，如果违反会出现意想不到的结果，请大家一定要遵守</p>
<p> hashCode方法默认返回对象的地址,String,Integer等封装类型对它进行了重写返回一个整数<br> 该整数的取值来自于当前字符串的每个字母的编码值.公示如下</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> “abcde”.hashCode();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 比如有一个字符串“abcde”,采用31进制的计算方法来计算这个字符串的总和，你会写出下面的计算式子：<br> a<em>31^4+b</em>31^3+c<em>31^2+d</em>31^1+e<em>31^0.注意，这里的a,b,c,d或者e指的是它们的ASCII值.<br> 那么为什么选用31作为基数呢？先要明白为什么需要HashCode.每个对象根据值计算HashCode,这个code大小虽然不奢求必须唯一（因为这样通常计算会非常慢），但是要尽可能的不要重复，因此基数要尽量的大。另外，31</em>N可以被编译器优化为左移5位后减1，有较高的性能.</p>
<p> 在Object类中定义了hashCode()方法和equals()方法，Object类的equals()方法按照内存地址比较对象是否相等，因此如果object.equals(object2)为true, 则表明object1变量和object2变量实际上引用同一个对象，那么object1和object2的哈希码也肯定相同。</p>
<p> 为了保证HashSet能正常工作， 要求当两对象用equals()方法比较的结果为true时，它们的哈希码也相等。如果用户定义的Customer类覆盖了Object类的equals()方法，但是没有覆盖Object类的hashCode()方法，就会导致当customer1.equals(customer2)为true时，而customer1和customer2的哈希码不一定一样，这会使HashSet无法正常工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</div><div class="line">       <span class="keyword">private</span> String name;</div><div class="line">       <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">              <span class="keyword">this</span>.name = name;</div><div class="line">              <span class="keyword">this</span>.age = age;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">              <span class="keyword">return</span> name;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">              <span class="keyword">return</span> age;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">              <span class="keyword">if</span>(<span class="keyword">this</span>==o) <span class="keyword">return</span> <span class="keyword">true</span>;                          </div><div class="line">              <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Customer)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">              Customer other = (Customer)o;</div><div class="line"></div><div class="line">              <span class="keyword">if</span>(<span class="keyword">this</span>.name.equals(other.getName()) &amp;&amp; <span class="keyword">this</span>.age.equals(other.getAge())</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">              <span class="keyword">else</span> </div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<p>以下程序向HashSet中加入两个Customer对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Set set = <span class="keyword">new</span> HashSet();</div><div class="line">Customer customer1 = <span class="keyword">new</span> Customer(<span class="string">"Tom"</span>, <span class="number">15</span>);</div><div class="line">Customer customer2 = <span class="keyword">new</span> Customer(<span class="string">"Tom"</span>, <span class="number">15</span>);</div><div class="line">set.add(customer1);</div><div class="line">set.add(customer2);</div><div class="line">System.out.println(set.size());         <span class="comment">//打印出 2</span></div></pre></td></tr></table></figure></p>
<p>出现以上原因在于customer1和customer2的哈希码不一样，因此为两为customer对象计算出不同的位置，于是把它们放到集中中的不同的地方。应加入以下hashCode()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> (name.hashCode())+age;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HashSet中元素比较执行顺序是先执行hashCode()，如果是对象(类类型)，使用对象的地址进行hashCode()，不同对象hashCode出来的值不同(默认hashCode方法会使用不同算法直到值不同为止)，如果是基本类型，则会比较基本类型的值。</p>
<ol>
<li><p>TreeSet<br>TreeSet实现了SortedSet接口，能够对集合中的对象进行排序。当TreeSet向集合中加入一个对象时，会把它插入到有序的对象序列中。那么TreeSet是如何对对象进行排序的呢？TreeSet支持两种排序方式：自然排序和客户化排序。默认情况TreeSet采用的是自然排序方式：</p>
<ol>
<li><p>自然排序  升序  默认返回负数</p>
<p>当前和传入的比较返回 升序<br>传入和当前的比较返回 降序</p>
<p>String类型比较大小,使用compareTo(Object obj)方法.</p>
<p>在JDK类库中， 有一部分类实现了Comparable接口，如Integer、Double和String等。Comparable接口有一个<br>compareTo(Object o)方法，它返回整数类型。对于x.comapreTo(y), 如</p>
<blockquote>
<p>x表示第一个值  y表示第二个值<br>返回0,       表明   x和y相等<br>返回值大于0, 表明   x&gt;y     1<br>返回值小于0, 表明   x&lt;y  -1</p>
</blockquote>
<p>例如：<br>当前类型 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">                Student implements Comparable &#123;</div><div class="line">	<span class="keyword">int</span> age;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">		Student stu = (Student)obj;</div><div class="line">		<span class="keyword">return</span> age-stu.age;当前age－传入对象的age  自然排序</div><div class="line">			stu.age-age;传入对象的age－当前age 降序排序</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TreeSet调用对象的compareTo()方法比较集合中对象的大小，然后进行升序排序，这种排序方式称为自然排序。<br>JDK类库中实现了Comparable接口的一些类的排序方式：<br>| 类型 | 排序方式 |<br>|—–|—–|<br>|  Byte, Short, Integer, Long, Double, Float  |  按数字大小排序  |<br>|  Character  |  按字符的Unicode值的数字大小排序  |<br>|  String  |  按字符串中字符的Unicode值排序  |<br>使用自然排序， TreeSet中只能加入相同类型对象，且这些对象必须实现了Comparable接口。否则会抛出ClassCastException异常。</p>
<p>最适合TreeSet排序的是类的内容可以操作,可以修改限定类的内容.</p>
</li>
<li><p>客户化排序</p>
<p>除了自然排序外， TreeSet还支持客户化排序。java.util.Comparator接口提供了具体的排序方法， 它有一个compare(Object x, Object y)方法，用于比较两个对象的大小</p>
<p>如果希望TreeSet按照Customer对象的name属性进行降序排列，可以先创建一个实现Comparator接口的类 CustomerComparator, 参见：</p>
<blockquote>
<p>使用compare(Object o1,Object o2)进行比较,一定要o1.compare(o2).如果想保持当前顺序,返回－1,如果想更改当前的顺序.返回1</p>
<pre><code>compare(Object o1,Object o2) {
      o1.compare(o2)&gt;0 return -1 时 表示降序
       o1.compare(o2)&lt;0  return 1 时 表示降序
      o1.compare(o2)&gt;0 return 1时 表示升序
      o1.compare(o2)&lt;0 return -1时 表示升序         
}
</code></pre></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">      <span class="keyword">import</span> java.util.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</div><div class="line">                     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</div><div class="line">                            Customer c1 = (Customer)o1;</div><div class="line">                            Customer c2 = (Customer)o2;</div><div class="line">                            <span class="keyword">if</span>(c1.getName().compareTo(c2.getName())&gt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">                            <span class="keyword">if</span>(c1.getName().compareTo(c2.getName())&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">                            Set set = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> CustomerComparator());</div><div class="line"></div><div class="line">                            Customer customer1 = <span class="keyword">new</span> Customer(<span class="string">"Tom"</span>,<span class="number">15</span>);</div><div class="line">                            Customer customer3 = <span class="keyword">new</span> Customer(<span class="string">"Jack"</span>,<span class="number">16</span>);</div><div class="line">                            Customer customer2 = <span class="keyword">new</span> Customer(<span class="string">"Mike"</span>,<span class="number">26</span>);</div><div class="line">                            set.add(customer1);</div><div class="line">                            set.add(customer2);</div><div class="line">                            set.add(customer3);</div><div class="line"></div><div class="line">                            Iterator it = set.iterator();</div><div class="line">               </div><div class="line">                            <span class="keyword">while</span>(it.hasNext()) &#123;</div><div class="line">                                  Customer customer = it.next();</div><div class="line">                                  System.out.println(customer.getName() + <span class="string">" "</span> + customer.getAge());</div><div class="line">                            &#125;</div><div class="line">                      &#125;</div><div class="line">               &#125;</div></pre></td></tr></table></figure>
<pre><code>打印输出：

Tom 15
Mike 26
Jack 16
</code></pre></li>
<li><p>LinkedHashSet<br>具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。</p>
</li>
</ol>
</li>
</ol>
<h4 id="3-Map接口"><a href="#3-Map接口" class="headerlink" title="3. Map接口"></a>3. Map接口</h4><p>请注意，Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射,只能通过entrySet()获取set实例，进而进行遍历，Map没有实现itrator,不能使用增强for循环.</p>
<ol>
<li><p>Hashtable类</p>
<p> Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。<br>添加数据使用put(key,  value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。</p>
<p> Hashtable通过initial  capacity和load  factor两个参数调整性能。通常缺省的load  factor  0.75较好地实现了时间和空间的均衡。增大load  factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。</p>
<p> 使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是”one”，”two”，”three”： </p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Hashtable  numbers  =  <span class="keyword">new</span>  Hashtable(); </div><div class="line">numbers.put(“one”,  <span class="keyword">new</span>  Integer(<span class="number">1</span>)); </div><div class="line">numbers.put(“two”,  <span class="keyword">new</span>  Integer(<span class="number">2</span>)); </div><div class="line">numbers.put(“three”,  <span class="keyword">new</span>  Integer(<span class="number">3</span>));</div></pre></td></tr></table></figure>
<p> 要取出一个数，比如2，用相应的key：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer  n  =  (Integer)numbers.get(“two”); </div><div class="line">System.out.println(“two  =  ”  +  n);</div></pre></td></tr></table></figure>
<p> 由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方法。hashCode和equals方法继承自根类Object，如果你用自定义的类当作key的话，要相当小心，按照散列函数的定义，如果两个对象相同，即obj1.equals(obj2)=true，则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希表的操作。 </p>
<p> 如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。Hashtable是同步的。 </p>
</li>
<li><p>HashMap类</p>
<p> HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null  value和null  key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load  factor过低。 </p>
</li>
<li><p>WeakHashMap类</p>
<p> WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。 </p>
</li>
<li><p>SortedMap类</p>
<p> 有序的，按照key值的自然排序规则或者在创建SortedMap集合时指定的Comparator进行排序。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。
</code></pre><p><img src="https://sarience.github.io/img/pic/collectionAMap.png" alt=""></p>
<p>Tips:</p>
<ol>
<li><p>Collection 和 Collections的区别。 </p>
<p> Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。<br> Collection是个java.util下的接口，它是各种集合结构的父接口。 </p>
</li>
<li><p>List, Set, Map是否继承自Collection接口? </p>
<p> List，Set是  Map不是 </p>
</li>
<li><p>ArrayList和Vector的区别。 </p>
<p> 一.同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的<br> 二.数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半 </p>
</li>
<li><p>HashMap和Hashtable的区别 </p>
<p> 一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现<br> 二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的<br> 三.值：只有HashMap可以让你将空值作为一个表的条目的key或value </p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android Studio Plugins]]></title>
      <url>/2017/05/02/Android-Studio-Plugins/</url>
      <content type="html"><![CDATA[<ol>
<li><p>ButterKnife Zelezny<br>ButterKnife 注解生成器，使用起来非常简单方便<br><img src="https://sarience.github.io/img/pic/zelezny_animated.gif" alt=""></p>
</li>
<li><p>GsonFormat<br>根据api接口生成相应的实体类<br><img src="https://sarience.github.io/img/pic/gson_format.gif" alt=""></p>
</li>
<li><p>Android Parcelable Code Generator<br>Android中的序列化有两种方式，分别是实现Serializable接口和Parcelable接口，但在Android中是推荐使用Parcelable<br><img src="https://sarience.github.io/img/pic/parcelable_generator.png" alt=""></p>
</li>
<li><p>Android Postfix Completion<br>可根据后缀快速完成代码，这个属于拓展吧，系统已经有这些功能，如sout、notnull等，这个插件在原有的基础上增添了一些新的功能<br><img src="https://sarience.github.io/img/pic/Postfix.gif" alt=""></p>
</li>
<li><p>Lifecycle Sorter<br>可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K<br><img src="https://sarience.github.io/img/pic/Lifecycle.gif" alt=""></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[oracle数据库导入与导出]]></title>
      <url>/2017/05/01/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/</url>
      <content type="html"><![CDATA[<h4 id="导出命令："><a href="#导出命令：" class="headerlink" title="导出命令："></a>导出命令：</h4><p>1)单表导出：exp 用户名/密码@服务器别名 tables=表名 file=d:\名称.dmp<br>例如：</p>
<blockquote>
<p>exp douya/douya@127.0.0.1 tables=message file=~/message.dmp<br><img src="https://sarience.github.io/img/pic/oracle_exp.png" alt=""></p>
</blockquote>
<p>2)多张表：exp 用户名/密码@服务器别名 tables=表名1,表名2… file=d:\名称.dmp</p>
<blockquote>
<p> exp douya/douya@127.0.0.1 file=~/mp.dmp tables=message,person<br><img src="https://sarience.github.io/img/pic/oracle_expmulti.png" alt=""></p>
</blockquote>
<p>3)完全导出：也就是数据库中的所有表都导出格式：exp 用户名/密码@服务器别名 file=d:\名称.dmp</p>
<blockquote>
<p>exp douya/douya@127.0.0.1 file=~/all.dmp<br><img src="https://sarience.github.io/img/pic/oracle_expall.png" alt=""></p>
</blockquote>
<h4 id="导入命令"><a href="#导入命令" class="headerlink" title="导入命令:"></a>导入命令:</h4><p>因为导入的内容都是dmp文件，所以未涉及到单表导入的情况，统一命令格式</p>
<p>格式：</p>
<blockquote>
<p>imp 新用户名/密码@新服务器别名 file=d:\名称.dmp buffer=102400000 feedback=10000 log=d:\名称.txt full=y</p>
</blockquote>
<p>例：</p>
<blockquote>
<p>imp douya/douya@127.0.0.1 file=~/all.dmp buffer=10240000 feedback=10000 log=~/impall.txt full=y<br><img src="https://sarience.github.io/img/pic/oracle_impall.png" alt=""><br><img src="https://sarience.github.io/img/pic/oracle_impall2.png" alt=""></p>
</blockquote>
<p>参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>buffer</td>
<td>设置缓存大小，越大越好，它决定导入的速度</td>
</tr>
<tr>
<td>full</td>
<td>完全导入，导出表结构及存储过程等等</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> oracle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WPS for Linux（ubuntu）字体配置(字体缺失解决办法)]]></title>
      <url>/2017/04/28/WPS-for-Linux%EF%BC%88ubuntu%EF%BC%89%E5%AD%97%E4%BD%93%E9%85%8D%E7%BD%AE-%E5%AD%97%E4%BD%93%E7%BC%BA%E5%A4%B1%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>启动WPS for Linux后，出现提示”系统缺失字体” 。</p>
<p>出现提示的原因是因为WPS for Linux没有自带windows的字体，只要在Linux系统中加载字体即可。</p>
<p>具体操作步骤如下：</p>
<ol>
<li><p>下载缺失的字体文件，然后复制到Linux系统中的/usr/share/fonts文件夹中。<br>国外下载地址：<a href="https://www.dropbox.com/s/lfy4hvq95ilwyw5/wps_symbol_fonts.zip" target="_blank" rel="external">https://www.dropbox.com/s/lfy4hvq95ilwyw5/wps_symbol_fonts.zip</a><br>国内下载地址：<a href="http://pan.baidu.com/s/1mh0lcbY" target="_blank" rel="external">http://pan.baidu.com/s/1mh0lcbY</a><br>（上述数据来源网络，侵删）<br>下载完成后，解压并进入目录中，继续执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cp * /usr/share/fonts</div></pre></td></tr></table></figure>
</li>
<li><p>执行以下命令,生成字体的索引信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkfontscale</div><div class="line">sudo mkfontdir</div></pre></td></tr></table></figure>
</li>
<li><p>运行fc-cache命令更新字体缓存。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo <span class="built_in">fc</span>-cache</div></pre></td></tr></table></figure>
</li>
<li><p>重启wps即可，字体缺失的提示不再出现。</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[白色相簿2重温]]></title>
      <url>/2017/04/26/%E7%99%BD%E8%89%B2%E7%9B%B8%E7%B0%BF2%E9%87%8D%E6%B8%A9/</url>
      <content type="html"><![CDATA[<p>上周四把白色相簿2又重温了一遍，还是觉得很虐心，不仅仅心疼冬马和纱，也心疼小木曾雪菜・(PД`q｡)・゜。</p>
<p>东马是最先与北原春希相互爱慕的，从他们的钢琴与吉他的合奏中不难听出来，而且东马还是春希的老师，音乐的指导引领着，只是春希并不知道那位与他合奏的那位居然是他的同桌东马，而且指导过他的吉他。冬马或许在等，等一个机会，等她有足够多的勇气去和春希表白，也或许在等春希去解开这个秘密。可惜，人生总有那么些意外，意外插入他们之间的那位歌手小木曾雪菜，在与春希的接触中被春希所吸引而爱上了春希，而冬马是那位钢琴手的秘密也无意间被春希解开。雪菜在看出春希对冬马的情义之后感觉到了危机，便下意识地与冬马较量，尤其是春希与冬马一周的和宿训练，春希的私人物品被雪菜无意间发现后，春希的醋意更浓了，而冬马也在雪菜一次次的醋意促动下在学园祭上正式接受了雪菜的挑战，甚至有主动迎战，可是在学园祭结束后，在第二教室，听了春希对雪菜的称赞，而自己被称为“那家伙”后，很难受，她再一次的退缩了，在春希睡着后吻了春希之后离去。</p>
<p>而这一切都被雪菜看见了，雪菜在冬马离去后为春希披上了外套，并在春希醒来后表白了，而春希，在雪菜这种温柔的攻势下显得毫无还手能力，只能乖乖就擒。雪菜在这里表现出的果断让她取得了胜利，而胜利的原因还有春希面对他人的请求不善于拒绝的性格。而后的冬马一直与春希保持距离，甚至躲避，而雪菜在获得爱情后却还想着拥有与冬马之间的友谊，正是雪菜的“贪婪”更加让冬马想要逃离，而冬马的逃离却也更加地促进了春希对冬马的执着，而且春希也更加想证明冬马是不是还爱着他，因为春希觉得自己爱冬马更多一些。在雪菜的生日那天，春希得知冬马要去巴黎的消息后，去找冬马，在街道上一阵倾诉后知道冬马一直是爱着自己的，两人相拥而吻，而冬马却意外推开春希并给了一个耳光，说出了那句让我吃了一整瓶胃药的话-“你为什么那么熟练啊！”，是啊，本来你接受雪菜的表白就已经把我推开，而你熟练的吻技更加让我心痛，你是要把我推的多远你才甘心(┙&gt;∧&lt;)┙へ┻┻ 。</p>
<p>后来的毕业典礼上，冬马给雪菜留了一封信，雪菜告诉春希后，春希对冬马的感情一下子被激发，不顾基友提醒自己还是雪菜男朋友的事实去找冬马。在寻找未果之后陷入无尽的痛苦的春希接到了冬马打来的最后一通电话，当冬马正要带着最后一丝眷恋离开的时候被春希找到，两人又是一阵倾诉，后来两人发生了关系。第二天是冬马去巴黎的日子，雪菜拉着春希去送冬马，两人在路上坦白了一切，雪菜因该是在赌最后一把吧，可惜，这次她输了，春希选择了冬马，而冬马也没有拒绝春希，两人在机场相拥而泣。冬马最终还是去了巴黎，雪菜安慰春希回家被拒后依然温柔陪伴，诶诶诶，这里我就不怎么懂了，冬马和春希只是异国恋吧，这里雪菜对春希还抱有希望还是以朋友身份呢？个人感觉是以朋友身份吧。(个人还是比较倾向于冬马吧，不服憋着，哼 (￣３￣))</p>
<p>冬马的傲娇与春希的优柔寡断和雪菜的一如既往的温柔包容促成了整个故事的悲剧，没有谁绝对对，谁绝对错，不论春希最后是和谁在一起，对另一个人都不好受，诶等等，为什么没有百合线，我觉得冬马和雪菜在一起不错嘛，哈哈╮(╯▽╰)╭    。</p>
<p>注：限于个人因素，所述或许并不客观，如需全集，请移步哔哩哔哩：<a href="http://bangumi.bilibili.com/anime/3516?from=search&amp;seid=14186857277192241694" target="_blank" rel="external">传送门</a></p>
]]></content>
      
        <categories>
            
            <category> 动漫 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 动漫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java修饰符]]></title>
      <url>/2017/04/26/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      <content type="html"><![CDATA[<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><pre><code>变量：
    1.只能是成员变量，类变量，
    2.类的实例所共享。
    3.在权限允许范围内可以直接通过类名.变量名的形式访问
    4.某种意义上更类似于全局变量。
方法：
    1.类方法
    2.在权限允许范围内可以直接通过类名.方法名访问    

    Note：
        static方法不能被重写为非静态的方法
        并且static方法就算被重写也不会有多态的体现。
    Animal an = new Cat();
    an.shout();
代码块：
    static修饰的代码块在类加载的时候执行一次
    没有static修饰的代码块在每一次构建对象时执行一次


在所有的静态上下文中不能访问非静态的成员(变量和方法)。
</code></pre><h3 id="静态导入："><a href="#静态导入：" class="headerlink" title="静态导入："></a>静态导入：</h3><pre><code>import static packageName.clsname.staticMember;
</code></pre><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><pre><code>1.变量：final修饰的变量时常量。必须进行显示初始化。
    1.实例变量：
        初始化过程三选一(必须且只能选一个)
        1.声明即初始化
            final int a = 100;
        2.在匿名代码块中进行初始化：
            final int a;
            {
                a = 100;
            }
        3.可以在构造器中进行显示初始化：
            要求在类中的每一个构造器中都要进行初始化。
    2.类变量：
        二选一（必选）：
        1.声明即初始化
            static final int b = 200;
        2.在静态代码块中初始化：
    3.局部变量：
        在使用之前进行显示初始化。
2.方法：
    final修饰的方法不能被覆盖（重写）
3.类：
    final修饰的类不能被继承。
</code></pre><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><pre><code>1.方法：抽象方法
    1.不能有方法体
    2.抽象方法所在类一定是抽象类。
    3.抽象方法存在就是被覆盖的。如果子类继承了带有抽象方法的抽象类，必须对所有的抽象方法进行覆盖。
    4.多态。
2.类：抽象类
    1.抽象类不能被实例化。但是可以声明抽象类类型的变量。
    2.抽象类是对类的抽象，抽象类所具有的共有特征和行为。
    3.抽象类存在的目的就是用来被继承，实现代码复用。
    4.抽象类中可以有抽象方法，也可以没有。抽象类可以和普通类一模一样（拥有各种类型的变量和方法）
    5.如果一个类继承抽象类，必须实现抽象类中所有抽象方法，或者子类本身也是抽象类。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;</div><div class="line">&#125;</div><div class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Action</span></span>&#123;</div><div class="line">		 <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">		 <span class="function"><span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span></span>;</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">USBDevice</span></span>&#123;</div><div class="line">		xx = <span class="string">""</span>; </div><div class="line">		driver();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">let</span><span class="params">()</span></span>&#123;</div><div class="line">		</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><pre><code>1.接口是比抽象类还抽象的存在，接口是抽象类的极致抽象。
2.接口中所有的方法都是public abstracht，接口中所有的变量都是public static final
3.接口主要用来定义标准。
4.接口可以多继承。一个类可以实现多个接口。
5.接口的存在本身可以规避java不能多继承的操作特点。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USBDevice</span></span>&#123;</div><div class="line">	String type=<span class="string">"USB"</span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">driver</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span></span>&#123;</div><div class="line">	select();</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">USBMouse</span> <span class="keyword">extends</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">USBDevice</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">(USBDevice usb)</span></span>&#123;</div><div class="line">		usb.driver();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>对象：
    1.信息载体对象(域对象)
    2.行为对象
</code></pre><h3 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h3><pre><code>定义在类体部，方法体部，甚至比方法体更小的代码块内部的类
1.静态内部类（内部类中最简单的形式）
    1.声明在类体部，方法体外，并且使用static修饰的内部类
    2.访问特点可以类比静态变量和静态方法
    3.脱离外部类的实例独立创建
        在外部类的外部构建内部类的实例
            new Outer.Inner();
        在外部类的内部构建内部类的实例
            new Inner();
    4.静态内部类体部可以直接访问外部类中所有的静态成员，包含私有
2.成员内部类(实例内部类)
    1.没有使用static修饰的内部类。
    2.在成员内部类中不允许出现静态变量和静态方法的声明。
        static只能用在静态常量的声明上。
    3.成员内部类中可以访问外部类中所有的成员(变量，方法)，包含私有成员，如果在内部类中定义有和外部类同名的实例变量，访问：
        OuterClass.this.outerMember;
    4.构建内部类的实例，要求必须外部类的实例先存在
        外部类的外部/外部类的静态方法：new Outer().new Inner();
        外部类的实例方法：
            new Inner();
            this.new Inner();
3.局部内部类:
    1.定义在方法体，甚至比方法体更小的代码块中
    2.类比局部变量。
    3.局部内部类是所有内部类中最少使用的一种形式。
    4.局部内部类可以访问的外部类的成员根据所在方法体不同。
        如果在静态方法中：
            可以访问外部类中所有静态成员，包含私有
        如果在实例方法中：
            可以访问外部类中所有的成员，包含私有。
      局部内部类可以访问所在方法中定义的局部变量，但是要求局部变量必须使用final修饰。

4.匿名内部类
    1.没有名字的局部内部类。
    2.没有class,interface,implements,extends关键字
    3.没有构造器。
    4.一般隐式的继承某一个父类或者实现某一个接口
</code></pre>]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何使用SimpleScreenRecorder进行Ubuntu屏幕录制]]></title>
      <url>/2017/04/25/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8SimpleScreenRecorder%E8%BF%9B%E8%A1%8CUbuntu%E5%B1%8F%E5%B9%95%E5%BD%95%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>今天突然发现自己需要录制视频，而Ubuntu没有像Kali一样自带录频软件，所以有了这篇笔记</p>
<h4 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h4><p>在终端中使用如下命令安装 SimpleScreenRecorder：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:maarten-baert/simplescreenrecorder</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install simplescreenrecorder</div></pre></td></tr></table></figure></p>
<p>如果你需要在 64 位 Ubuntu 上录制 32位 OpenGL 应用程序，请安装 simplescreenrecorder-lib:i386：</p>
<p><code>sudo apt-get install simplescreenrecorder-lib:i386</code></p>
<p><img src="https://sarience.github.io/img/pic/simpleScRecoder.png" alt=""></p>
<p>画图工具也一并讲了吧，我用的是Kolourpaint，输入如下命令安装<br><code>sudo apt-get install kolourpaint4</code></p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中子父类静态代码块，代码块，构造方法的执行顺序]]></title>
      <url>/2017/04/25/Java%E4%B8%AD%E5%AD%90%E7%88%B6%E7%B1%BB%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>我们来看一段代码和执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.douya.Test;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by douya on 17-4-25.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> B();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            System.out.println(<span class="string">"static A"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"codeBlock A"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"constructor A"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            System.out.println(<span class="string">"static B"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        &#123;</div><div class="line">            System.out.println(<span class="string">"codeBlock B"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"constructor B"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果：</p>
<blockquote>
<p>static A<br>static B<br>codeBlock A<br>constructor A<br>codeBlock B<br>constructor B</p>
</blockquote>
<p><img src="https://sarience.github.io/img/pic/order.png" alt=""></p>
<p>结论：<br>两大原则：</p>
<ol>
<li>父类先行</li>
<li>静态方法先行</li>
</ol>
<p>故而执行顺序为：父类静态方法-&gt;子类静态方法-&gt;父类代码块-&gt;父类构造方法-&gt;子类代码块-&gt;子类构造方法</p>
<p><img src="https://sarience.github.io/img/pic/variable_super_this.png" alt=""></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>看如下代码和运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.douya.day9;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by douya on 17-5-3.</div><div class="line"> */</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">this</span>.display();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">22</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Derived</span><span class="params">()</span> </span>&#123;</div><div class="line">        i = <span class="number">222</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhoIsThis</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Derived();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>com.douya.day9.Derived@3fee733d<br>0</p>
</blockquote>
<p>如果你熟悉子父类的创建和调用就好办了，在new 子类时，this指向的是子类，调用方法时，子类方法覆盖父类同名方法，父类与子类如果有同名属性，则调用的属性要看调用的主体是谁，是父类那就是父类的属性，是子类就是子类的属性。这里display()调用子类display，i是子类的i，子类i在 此时还未被赋值，故其值为0.</p>
<h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><p>相信你一定懂了，那么我们一起来巩固一下吧～<br>下面程序的运行结果是什么呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.douya.day9;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.DDIV;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by douya on 17-5-3.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBase</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.count);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DDerived</span> <span class="keyword">extends</span> <span class="title">BBase</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">20</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.count);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAndDerived</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        BBase bBase = <span class="keyword">new</span> BBase();</div><div class="line">        System.out.println(bBase.count);</div><div class="line">        bBase.display();</div><div class="line"></div><div class="line">        DDerived dDerived = <span class="keyword">new</span> DDerived();</div><div class="line">        System.out.println(dDerived.count);</div><div class="line">        dDerived.display();</div><div class="line"></div><div class="line">        BBase bd = <span class="keyword">new</span> DDerived();</div><div class="line">        System.out.println(bd.count);</div><div class="line">        bd.display();</div><div class="line"></div><div class="line">        BBase b2d = dDerived;</div><div class="line">        System.out.println(b2d.count);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>答案：</p>
<blockquote>
<p>2<br>2<br>20<br>20<br>2<br>20</p>
</blockquote>
<p>Tips:<br>内存中并不存在所有的父类，只是子类保留了父类的所定义的所有实例变量，拥有父类的数据结构</p>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java面向对象编程的特征(查漏补缺)]]></title>
      <url>/2017/04/25/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
      <content type="html"><![CDATA[<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ol>
<li>信息的隐藏以及行为实现细节的隐藏。</li>
<li>维护数据的一致性和安全性</li>
<li>缩小访问权限（private）,将信息私有化话之后，如果需要和其他对象之间进行交流，可以通过提供统一访问入口的方法提供给所有人统一访问方式。</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>目的：父类代码的复用。简化子类构建过程。<br>       Note:<br>        1.满足is a或者is kind of语义关系<br>        2.子类可以继承父类所具有的属性和行为。<br>        3.子类还可以具有比父类更多的特征。<br>        4.子类可以具有和父类完全同名的方法，子类可以覆盖父类本身所具有的行为。<br>        5.子类可以 具有和父类完全一致的属性。<br>        6.可以使用父类类型的变量接收子类类型的对象实例</p>
<h4 id="引用类型数据类型转换："><a href="#引用类型数据类型转换：" class="headerlink" title="引用类型数据类型转换："></a>引用类型数据类型转换：</h4><pre><code>1.隐式：
    父类类型的引用指向子类对象
    ShoutAnimal an = new Dog();
2.显示：
    Dog d = (Dog)an;
    Cat c = (Cat)an;
只要满足继承关系的子父类在进行强制(显示)类型转换时，编译期语法都可以通过，但是运行时有可能出现跨种族转换(虚拟机抛出ClassCastException),为了在运行时减少类型转换异常，推荐，在使用引用类型的强制类型转换之前先使用instanceof判断是否能够进行转换。
an instanceof ShoutAnimal :  true
an instanceof Dog:             true
an instanceof Cat:             false
</code></pre><p>Tips:若子类强转为父类，则父类的引用指向子类的对象，这话没错，但是，也只能说半对，为啥，来看看这段代码和运行结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.douya.Test;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by douya on 17-4-25.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        A b2a = <span class="keyword">new</span> B(<span class="string">"I'm B"</span>);</div><div class="line">        System.out.println(b2a.name);</div><div class="line">        b2a.pr();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">       String name;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pr</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">        String  name;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pr</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果:</p>
<blockquote>
<p>null<br>I’m B</p>
</blockquote>
<p>代码很简单，就是子类与父类具有共同的方法和属性，在main中，创建了一个子类对象B，隐式转换成父类A，并使用该引用b2a访问属性name，访问方法pr()。调用方法不难理解，但是调用属性肯定很多人会理解错，认为结果应该是传入的值<code>I&#39;m B</code>，但是运行结果摆在这里了，我们就好好来理解一下吧。(关于默认修饰符protect修饰的属性能不能继承请看:<a href="https://sarience.github.io/2017/04/24/Java%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E4%BF%AE%E9%A5%B0%E7%AC%A6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/">传送门</a>，这里就不再展开讲了)</p>
<ol>
<li><p>在执行<code>new B(&quot;I&#39;m B&quot;);</code>的时候发生了什么呢，当然是先创建了父类A，后创建了子类B(若子类中有静态方法，则先执行父类的静态方法，后执行子类静态方法，然后依次执行父类代码块和构造方法，再依次执行子类代码块和构造方法：<a href="https://sarience.github.io/2017/04/25/Java%E4%B8%AD%E5%AD%90%E7%88%B6%E7%B1%BB%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">详情参考</a>)。</p>
</li>
<li><p>那么<code>A b2a</code>中的<code>b2a</code>指向的是父类还是子类B呢，一般书上都会讲是指向子类B，这样说没错，但严格意义上是指向父类的，指向子类还是父类是由类型修饰符来决定的，这里是<code>A</code>，所以，<code>b2a</code>取<code>name</code>属性取用的是父类的<code>name</code>，而父类的<code>name</code>没有赋值，即为空值null，如下图:</p>
</li>
</ol>
<p><img src="https://sarience.github.io/img/pic/codingToO.png" alt=""></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><pre><code>1. 运行时多态
 相同类域的不同对象在调用相同方法时的表现不同
方法的重写
    1. 有子父类继承关系存在/接口和实现类关系
    2. 子类覆盖父类的行为/实现类实现接口中的方法
    3. 父类类型的引用指向子类对象/接口类类型的引用指向实现类的对象
    4. 调用被 重写了的方法/调用被实现了的方法
2. 编译时多态
    方法的重载
    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</div><div class="line">	getArea(<span class="keyword">int</span> r)&#123;</div><div class="line">		System.out.println(<span class="string">"圆形"</span>);</div><div class="line">	&#125;</div><div class="line">	getArea(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</div><div class="line">		System.out.println(<span class="string">"三角形"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre>]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu中vim显示行号以及解决上下左右是ABCD的问题]]></title>
      <url>/2017/04/25/Ubuntu%E4%B8%ADvim%E6%98%BE%E7%A4%BA%E8%A1%8C%E5%8F%B7%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E4%B8%8A%E4%B8%8B%E5%B7%A6%E5%8F%B3%E6%98%AFABCD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>一开始使用vim进行文本编辑的时候，发现上下左右没有进行光标移动，而是变成了ABCD输入了，原始的vi进行光标的移动是用字母键的，而新的vim作为vi的升级版，更加符合人们的使用习惯。于是乎，我们只需将vi升级成vim便能解决问题。<br><code>sudo apt-get install vim</code></p>
<p>恩，这个问题解决了，可是行号怎么办？别急，在命令模式下，输入<code>set nu</code>，便可以显示行号了。但是每编辑一个文件都输入一次很麻烦，有没有只配置一次就能解决的方案呢？当然有啦，如下：</p>
<h2 id="为所有用户设置"><a href="#为所有用户设置" class="headerlink" title="为所有用户设置"></a>为所有用户设置</h2><ol>
<li><p>进入到vim的安装文件夹<br><code>cd /usr/share/vim</code></p>
</li>
<li><p>编辑vimrc文件<br><code>sudo vi vimrc</code></p>
</li>
<li>添加你的设置，这里是<code>set nu</code><br><code>set nu  &quot;显示行数</code></li>
</ol>
<p><img src="https://sarience.github.io/img/pic/vimshare.png" alt=""></p>
<h2 id="只为当前用户设置"><a href="#只为当前用户设置" class="headerlink" title="只为当前用户设置"></a>只为当前用户设置</h2><ol>
<li>进入到当前用户的家目录<br><code>cd  ~</code></li>
<li>编辑<code>.vimrc</code>文件，如果没有，则创建<br><code>sudo vi vimrc</code></li>
<li>添加你的设置<br><code>set nu</code></li>
</ol>
<p><img src="https://sarience.github.io/img/pic/vimhome.png" alt=""></p>
<h2 id="更多设置"><a href="#更多设置" class="headerlink" title="更多设置"></a>更多设置</h2><p>当然了，便捷设置不可能只有这一种，以下列出一部分用于参考，各取所需吧</p>
<table>
<thead>
<tr>
<th>设置</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>set autoindent</td>
<td>自动缩进</td>
</tr>
<tr>
<td>set smartindent</td>
<td>智能缩进</td>
</tr>
<tr>
<td>set nu</td>
<td>“显示行数</td>
</tr>
<tr>
<td>set mouse=a</td>
<td>“自动换行</td>
</tr>
<tr>
<td>set nocompatible</td>
<td>关闭 vi 兼容模式</td>
</tr>
<tr>
<td>syntax on</td>
<td>自动语法高亮</td>
</tr>
<tr>
<td>colorscheme molokai</td>
<td>设定配色方案</td>
</tr>
<tr>
<td>set number</td>
<td>显示行号</td>
</tr>
<tr>
<td>set cursorline</td>
<td>突出显示当前行</td>
</tr>
<tr>
<td>set ruler</td>
<td>打开状态栏标尺</td>
</tr>
<tr>
<td>set shiftwidth=4</td>
<td>设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4</td>
</tr>
<tr>
<td>set softtabstop=4</td>
<td>使得按退格键时可以一次删掉 4 个空格</td>
</tr>
<tr>
<td>set tabstop=4</td>
<td>设定 tab 长度为 4</td>
</tr>
<tr>
<td>set nobackup</td>
<td>覆盖文件时不备份</td>
</tr>
<tr>
<td>set autochdir</td>
<td>自动切换当前目录为当前文件所在的目录</td>
</tr>
<tr>
<td>filetype plugin indent on</td>
<td>开启插件</td>
</tr>
<tr>
<td>set backupcopy=yes</td>
<td>设置备份时的行为为覆盖</td>
</tr>
<tr>
<td>set ignorecase smartcase</td>
<td>搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感</td>
</tr>
<tr>
<td>set nowrapscan</td>
<td>禁止在搜索到文件两端时重新搜索</td>
</tr>
<tr>
<td>set incsearch</td>
<td>输入搜索内容时就显示搜索结果</td>
</tr>
<tr>
<td>set hlsearch</td>
<td>搜索时高亮显示被找到的文本</td>
</tr>
<tr>
<td>set noerrorbells</td>
<td>关闭错误信息响铃</td>
</tr>
<tr>
<td>set novisualbell</td>
<td>关闭使用可视响铃代替呼叫</td>
</tr>
<tr>
<td>set t_vb=</td>
<td>置空错误铃声的终端代码</td>
</tr>
<tr>
<td>set showmatch</td>
<td>插入括号时，短暂地跳转到匹配的对应括号</td>
</tr>
<tr>
<td>set matchtime=2</td>
<td>短暂跳转到匹配括号的时间</td>
</tr>
<tr>
<td>set magic</td>
<td>设置魔术</td>
</tr>
<tr>
<td>set hidden</td>
<td>允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存</td>
</tr>
<tr>
<td>set guioptions-=T</td>
<td>隐藏工具栏</td>
</tr>
<tr>
<td>set guioptions-=m</td>
<td>隐藏菜单栏</td>
</tr>
<tr>
<td>set smartindent</td>
<td>开启新行时使用智能自动缩进</td>
</tr>
<tr>
<td>set backspace=indent,eol,start</td>
<td>不设定在插入状态无法用退格键和 Delete 键删除回车符</td>
</tr>
<tr>
<td>set cmdheight=1</td>
<td>设定命令行的行数为 1</td>
</tr>
<tr>
<td>set laststatus=2</td>
<td>显示状态栏 (默认值为 1, 无法显示状态栏)</td>
</tr>
<tr>
<td>“set statusline=\ %&lt;%F[%1<em>%M%</em>%n%R%H]%=\ %y\ %0(%{&amp;fileformat}\ %{&amp;encoding}\ %c:%l/%L%)\</td>
<td>设置在状态行显示的信息</td>
</tr>
<tr>
<td>“set foldenable</td>
<td>开始折叠</td>
</tr>
<tr>
<td>“set foldmethod=syntax</td>
<td>设置语法折叠</td>
</tr>
<tr>
<td>“set foldcolumn=0</td>
<td>设置折叠区域的宽度</td>
</tr>
<tr>
<td>“setlocal foldlevel=1</td>
<td>设置折叠层数为</td>
</tr>
<tr>
<td>“set foldclose=all</td>
<td>设置为自动关闭折叠</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> vim </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vim </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu16安装Oracle 11g XE]]></title>
      <url>/2017/04/25/Ubuntu16%E5%AE%89%E8%A3%85Oracle-11g-XE/</url>
      <content type="html"><![CDATA[<p>在学习JavaEE过程中需要用到数据库，而老师用的是Windows下的oracle XE，我用的是Ubuntu，又不想装虚拟机，所以便到oracle官网下载了安装包，并参考了一些文章，记录一下安装过程，以此作为以后的参考笔记。</p>
<p>Tips:<em>什么是Oracle 11g XE呢？</em></p>
<blockquote>
<p>Oracle Database Express Edition 是Oracle Database的简装版，只有一个数据库实例XE，因此也叫Oracle Database XE。它拥有正式版的所有功能，只是在内存和数据大小上做了限制。适合初学者用来学习Oracle。</p>
</blockquote>
<h3 id="安装包下载与转换"><a href="#安装包下载与转换" class="headerlink" title="安装包下载与转换"></a>安装包下载与转换</h3><ol>
<li><p>从官网下载Oracle 11g XE安装包（需要创建账户登录后才能下载），下载的文件是oracle-xe-11.2.0-1.0.x86_64.rpm.zip也可以下载我提供的下载好的<a href="http://o7glqnnuw.bkt.clouddn.com/sarience/file/oracle-xe-11.2.0-1.0.x86_64.rpm.zip" target="_blank" rel="external">安装包</a></p>
</li>
<li><p>转换deb包（若下载了deb安装包，跳过此步骤：<a href="http://o7glqnnuw.bkt.clouddn.com/sarience/file/oracle-xe_11.2.0-2_amd64.deb" target="_blank" rel="external">deb安装包地址</a>）<br>由于官方只为Linux提供了rpm安装包（适用于CentOS，Redhat，Fedora），所以需要先转化deb包。</p>
<ol>
<li><p><em>解压到当前目录</em><br><code>unzip oracle-xe-11.2.0-1.0.x86_64.rpm.zip</code></p>
</li>
<li><p><em>安装.deb与.rpm包转换工具：alien</em><br><code>sudo apt-get install alien</code></p>
</li>
<li><p><em>生成deb包</em><br><code>sudo alien --scripts -d oracle-xe-11.2.0-1.0.x86_64.rpm</code></p>
</li>
<li><p><em>安装依赖类库</em><br><code>sudo apt-get install libaio1 unixodbc</code></p>
</li>
<li><p><em>创建配置文件</em><br>新建chkconfig文件<br>Oracle XE在Red Hat上安装时需要依赖/sbin chkconfig文件，Ubuntu没该文件安装时会报错。<br><code>sudo gedit /sbin/chkconfig</code><br>把下面内容贴进去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"># Oracle 11gR2 XE installer chkconfig hack for Ubuntu</div><div class="line">file=/etc/init.d/oracle-xe</div><div class="line">if [[ ! `tail -n1 $file | grep INIT` ]]; then</div><div class="line">echo &gt;&gt; $file</div><div class="line">echo &apos;### BEGIN INIT INFO&apos; &gt;&gt; $file</div><div class="line">echo &apos;# Provides: OracleXE&apos; &gt;&gt; $file</div><div class="line">echo &apos;# Required-Start: $remote_fs $syslog&apos; &gt;&gt; $file</div><div class="line">echo &apos;# Required-Stop: $remote_fs $syslog&apos; &gt;&gt; $file</div><div class="line">echo &apos;# Default-Start: 2 3 4 5&apos; &gt;&gt; $file</div><div class="line">echo &apos;# Default-Stop: 0 1 6&apos; &gt;&gt; $file</div><div class="line">echo &apos;# Short-Description: Oracle 11g Express Edition&apos; &gt;&gt; $file</div><div class="line">echo &apos;### END INIT INFO&apos; &gt;&gt; $file</div><div class="line">fi</div><div class="line">update-rc.d oracle-xe defaults 80 01</div></pre></td></tr></table></figure>
</li>
<li><p><em>给chkconfig添加执行权限</em><br><code>sudo chmod 755 /sbin/chkconfig</code></p>
</li>
<li><p><em>配置内核参数</em><br>新建60-oracle.conf<br><code>sudo gedit /etc/sysctl.d/60-oracle.conf</code><br>输入下面内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Oracle 11g XE kernel parameters</span></div><div class="line">fs.file-max=6815744</div><div class="line">net.ipv4.ip_local_port_range=9000 65000</div><div class="line">kernel.sem=250 32000 100 128</div><div class="line">kernel.shmmax=4163487744</div><div class="line">net.core.rmem_default=262144</div><div class="line">net.core.rmem_max=4194304</div><div class="line">net.core.wmem_default=262144</div><div class="line">net.core.wmem_max=1048576</div><div class="line">fs.aio-max-nr=1048576</div></pre></td></tr></table></figure>
</li>
<li><p><em>加载内核参数：</em><br><code>sudo service procps start</code><br>执行以下语句看看内核参数是否修改成功<br><code>sudo sysctl -q fs.file-max</code><br>如果返回结果是fs.file-max = 6815744就说明修改成功了。如果不是该数值的话，可能是安装依赖库的问题。(最好重启一下计算机)</p>
</li>
</ol>
</li>
</ol>
<h3 id="安装、配置端口等"><a href="#安装、配置端口等" class="headerlink" title="安装、配置端口等"></a>安装、配置端口等</h3><ol>
<li><p>安装Oracle XE，在deb安装包所在目录的终端下执行下面的命令<br><code>sudo dpkg --install oracle-xe_11.2.0-2_amd64.deb</code></p>
</li>
<li><p>配置xe端口、密码等，注意要输入数据库密码。<br><code>sudo /etc/init.d/oracle-xe configure</code></p>
</li>
</ol>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><ol>
<li><p>打开shell配置文件，Ubuntu默认shell是bash，配置文件是.bashrc。<br><code>sudo gedit ～/.bashrc</code></p>
</li>
<li><p>将以下内容复制到shell的配置文件中进去，如果原先配置过PATH环境变量的话，将现在的加进去就可以。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> ORACLE_HOME=/u01/app/oracle/product/11.2.0/xe</div><div class="line"><span class="built_in">export</span> ORACLE_SID=XE</div><div class="line"><span class="built_in">export</span> NLS_LANG=<span class="string">"`<span class="variable">$ORACLE_HOME</span>/bin/nls_lang.sh`"</span></div><div class="line"><span class="built_in">export</span> ORACLE_BASE=/u01/app/oracle</div><div class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$ORACLE_HOME</span>/lib:<span class="variable">$LD_LIBRARY_PATH</span></div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$ORACLE_HOME</span>/bin:<span class="variable">$PATH</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><ol>
<li>安装完成后，oracle-xe服务是默认启动的，并且会开机自启，可以通过sysv-rc-conf这个软件来设置。（建议关机前手动关掉oracle-xe服务，不然关机会很慢）<br><code>sudo service oracle-xe start</code><br>(启动完毕也重启一下计算机)</li>
</ol>
<h4 id="检查端口监听"><a href="#检查端口监听" class="headerlink" title="检查端口监听"></a>检查端口监听</h4><p><img src="https://sarience.github.io/img/pic/oracle_check.png" alt=""></p>
<p>卸载<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">apt-get remove --purge  oracle-xe</div><div class="line">rm /etc/default/oracle-xe</div><div class="line">rm –rf /u01</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> oracle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java含包名类的编译与执行]]></title>
      <url>/2017/04/24/java%E5%90%AB%E5%8C%85%E5%90%8D%E7%B1%BB%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
      <content type="html"><![CDATA[<p>如图，day3下有两个文件夹，一个bin，用来存放编译后的.class文件，一个src用来存放java文件<br><img src="https://sarience.github.io/img/pic/javaCompileARun.png" alt=""><br>在src下面我们写了两个带包名的java类，为Hello.java和World.java,包名均为com.douya.test<br><img src="https://sarience.github.io/img/pic/javaCompileARunsrc.png" alt=""><br>执行<code>javac -d bin src/*.java</code>将编译src下的所有的java文件，并且编译后的.class文件放在bin目录下，并在bin目录下生成相应的包路径<br><img src="https://sarience.github.io/img/pic/javaCompileARunC.png" alt=""><br><img src="https://sarience.github.io/img/pic/javaCompileARunC2.png" alt=""></p>
<p>依次执行<code>java -cp bin com.douya.test.Hello</code>，<code>java -cp bin com.douya.test.World</code>，参数<code>-cp</code>，全称<code>-classpath</code>指定Classpath路径，这里指定为当前目录下的<code>bin</code>，要执行的类需要<code>包名加类名来访问</code>，结果如下<br><img src="https://sarience.github.io/img/pic/javaCompileARunC3.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何载Ubuntu下搭建Hexo博客]]></title>
      <url>/2017/04/24/%E5%A6%82%E4%BD%95%E8%BD%BDUbuntu%E4%B8%8B%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<ol>
<li><p>安装Git</p>
<blockquote>
<p>sudo apt-get install git</p>
</blockquote>
</li>
<li><p>安装NodeJs</p>
<blockquote>
<p>wget -qO- <a href="https://raw.github.com/creationix/nvm/master/install.sh" target="_blank" rel="external">https://raw.github.com/creationix/nvm/master/install.sh</a> | sh<br>安装完成后，重启终端<br>nvm install stable</p>
</blockquote>
</li>
<li><p>安装Hexo</p>
<blockquote>
<p>npm install -g hexo-cli<br>npm install hexo –save</p>
</blockquote>
</li>
<li><p>初始化Hexo</p>
<blockquote>
<p>hexo init</p>
</blockquote>
</li>
<li><p>安装Hexo插件</p>
<blockquote>
<p>npm install hexo-generator-index –save<br>npm install hexo-generator-archive –save<br>npm install hexo-generator-category –save<br>npm install hexo-generator-tag –save<br>npm install hexo-server –save<br>npm install hexo-deployer-git –save<br>npm install hexo-deployer-heroku –save<br>npm install hexo-deployer-rsync –save<br>npm install hexo-deployer-openshift –save<br>npm install hexo-renderer-marked@0.2 –save<br>npm install hexo-renderer-stylus@0.2 –save<br>npm install hexo-generator-feed@1 –save<br>npm install hexo-generator-sitemap@1 –save<br>//安装 ejs，否则无法解析模板<br>npm install  </p>
</blockquote>
</li>
<li><p>安装Hexo部署工具</p>
<blockquote>
<p>npm install hexo-deployer-git –save</p>
</blockquote>
</li>
<li><p>生成Hexo静态文件</p>
<blockquote>
<p>hexo g</p>
</blockquote>
</li>
</ol>
<ol>
<li><p>开启Hexo本地服务，验证是否搭建成功</p>
<blockquote>
<p>hexo s -p 80<br>意思是在本地80端口开启hexo服务<br>浏览器访问localhost验证</p>
</blockquote>
</li>
<li><p>提交到github</p>
<ol>
<li>创建一个名为：yourname.github.io的分支</li>
<li>修改_config.yml文件，配置deploy的type类型为git，resp为你的分支访问方式(有两种，一种是ssh,使用密钥链接，适用于维护单个博客，方便使用;一种是https，提交需要输入您的github账户和密码，适用于维护多个博客)</li>
<li>hexo d提交到github</li>
</ol>
</li>
</ol>
<h3 id="github提交的两种方式"><a href="#github提交的两种方式" class="headerlink" title="github提交的两种方式"></a>github提交的两种方式</h3><ol>
<li>https<br>提交类型为https，repo填你的repository地址，如图：<br><img src="https://sarience.github.io/img/pic/hexoConstructHTTPS.png" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/Sarience/Sarience.github.io.git</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在提交的过程中，会需要你输入你的github账号和密码，账号密码正确后则提交成功</p>
<ol>
<li>ssh<br>提交类型为git，repo填你的repository地址，如图：<br><img src="https://sarience.github.io/img/pic/hexoConstructSSH.png" alt=""><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: git<span class="meta">@github</span>.com:Sarience/Sarience.github.io.git</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在执行<code>hexo d</code>之前，先要生成rsa秘钥并且将你的秘钥添加到repository的设置中：</p>
<pre><code>1. 执行`ssh-keygen -t rsa`，会在你的home目录下生成一个`.ssh`文件夹，其中会有两个秘钥，一个公钥，一个私钥
2. 执行`cat ~/.ssh/id_rsa.pub`
3. 将其内容复制并添加到repository中
</code></pre><p>记得勾选<code>Allow write access</code><br><img src="https://sarience.github.io/img/pic/hexoConstructRSA.png" alt=""></p>
<pre><code>4. 执行`ssh -T git@github.com`进行测试，看到`Hi [yourGithubAccount]! You&apos;ve successfully authenticated, but GitHub does not provide shell access.`说明秘钥添加成功
5. 设置用户信息：
`git config --global user.name &quot;[yourName]&quot;//用户名`
`git config --global user.email  &quot;[yourEmail]&quot;//填写自己的邮箱`
</code></pre>]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Ubuntu 16中安装python3.6]]></title>
      <url>/2017/04/24/%E5%9C%A8Ubuntu-16%E4%B8%AD%E5%AE%89%E8%A3%85python3-6/</url>
      <content type="html"><![CDATA[<p>注意:前提Ubuntu里已经安装了python，不管版本</p>
<ol>
<li><p>下载python3.6.1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgz</div><div class="line">tar -xvzf Python-3.6.1.tgz</div></pre></td></tr></table></figure>
</li>
<li><p>安装一些依赖包<br>由于等会我会装virtualenv，所以在编译安装前需要装zlib和readline<br>在ubuntu里，zlib叫zlib1g，相应的zlib-devel叫zlib1g.dev</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install readline.dev</div><div class="line">sudo apt-get install zlib1g.dev</div></pre></td></tr></table></figure>
</li>
<li><p>编译安装python</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">sudo make &amp;&amp; sudo  make install</div></pre></td></tr></table></figure></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在Ubuntu中创建swap分区文件并挂载]]></title>
      <url>/2017/04/24/%E5%A6%82%E4%BD%95%E5%9C%A8Ubuntu%E4%B8%AD%E5%88%9B%E5%BB%BAswap%E5%88%86%E5%8C%BA%E6%96%87%E4%BB%B6%E5%B9%B6%E6%8C%82%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>通常，Linux系统中swap分区可以通过两种方式指定，分别为：<br>一、在磁盘分区的时候格式化一个swap分区；<br>二、在文件系统中创建一个swap文件作为swap分区。<br>此文主要介绍第二种方式。步骤如下：</p>
<ol>
<li><p>创建文件<br><code>fallocate -l 8G /swapfile</code><br>说明：8G 表示swap文件大小，/swapfile为swap文件路径和名称，可以任意指定。</p>
</li>
<li><p>修改文件权限<br><code>chmod 600 /swapfile</code></p>
</li>
<li><p>将 swapfile 初始化为交换文件<br><code>mkswap /swapfile</code></p>
</li>
<li><p>启用交换文件<br><code>swapon /swapfile</code></p>
</li>
<li><p>至此，linux系统已经将swapfile作为交换文件使用，但是重启之后是不会自动挂在刚才创建的文件的，因此需要手动修改 /etc/fstab 配置文件：<br><code>gedit /etc/fstab</code><br>在文件中添加如下内容：<br><code>/swapfile none swap sw 0 0</code></p>
</li>
<li><p>完成，测试下：<br><code>swapon -s</code></p>
</li>
</ol>
<p>提示：<br>        如果需要卸载swap分区文件，可以使用命令：<code>swapoff /swapfile</code></p>
]]></content>
      
        <categories>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java参数传递与修饰符访问权限]]></title>
      <url>/2017/04/24/Java%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E4%BF%AE%E9%A5%B0%E7%AC%A6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[<p>终于想通了困扰我的String类型传递不修改值的问题了，先说说参数传递吧。</p>
<p>如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.douya.Test;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamPass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String str = <span class="string">"main"</span>;</div><div class="line">        ParamPass pt = <span class="keyword">new</span> ParamPass();</div><div class="line">        System.out.println(<span class="string">"main before change1:"</span> + str);</div><div class="line">        pt.change1(str);</div><div class="line">        System.out.println(<span class="string">"main after change1:"</span> + str);</div><div class="line">        <span class="keyword">int</span> a = <span class="number">200</span>;</div><div class="line">        pt.change1(a);</div><div class="line">        System.out.println(a);</div><div class="line"></div><div class="line">        Student bfs = <span class="keyword">new</span> Student(<span class="number">20</span>, <span class="string">"BFS"</span>, <span class="keyword">false</span>);</div><div class="line">        System.out.println(<span class="string">"main before change1:"</span> + bfs);</div><div class="line">        pt.change1(bfs);</div><div class="line">        System.out.println(<span class="string">"main after change1:"</span> + bfs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change1</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"change1="</span> + str);</div><div class="line">        str = <span class="string">"change1"</span>;</div><div class="line">        System.out.println(<span class="string">"after change1:"</span> + str);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"change1="</span> + a);</div><div class="line">        a = <span class="number">100</span>;</div><div class="line">        System.out.println(<span class="string">"after change1:"</span> + a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change1</span><span class="params">(Student student)</span> </span>&#123;</div><div class="line">        student.setAge(<span class="number">18</span>);</div><div class="line">        student.setGender(<span class="keyword">true</span>);</div><div class="line">        student.setName(<span class="string">"AFS"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> gender;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.age = age;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name, <span class="keyword">boolean</span> gender)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.age = age;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.gender = gender;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> age;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.age = age;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> name;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isGender</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> gender;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(<span class="keyword">boolean</span> gender)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.gender = gender;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</div><div class="line">                    <span class="string">"age="</span> + age +</div><div class="line">                    <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</div><div class="line">                    <span class="string">", gender="</span> + gender +</div><div class="line">                    <span class="string">'&#125;'</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<blockquote>
<p>main before change1:main<br>change1=main<br>after change1:change1<br>main after chan<img src="http://" alt="">ge1:main<br>change1=200<br>after change1:100<br>200<br>main before change1:Student{age=20, name=’BFS’, gender=false}<br>main after change1:Student{age=18, name=’AFS’, gender=true}</p>
</blockquote>
<h3 id="Java中的数据类型"><a href="#Java中的数据类型" class="headerlink" title="Java中的数据类型"></a>Java中的数据类型</h3><p>Java中有8种<strong>基本数据类型</strong>，分别为：<br><code>布尔型(boolean)</code>,<br><code>字符型(char)</code>,<br><code>数值型(分两种)</code>:</p>
<pre><code>1. [整数类型]{byte,short,int,long},
2. [浮点类型]{float,double}
</code></pre><p>3种<strong>引用数据类型</strong>，分别为：</p>
<p><code>类(class)</code>,<br><code>接口(interface)</code>,<br><code>数组</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">graph TD;</div><div class="line">数据类型--&gt;基本数据类型;</div><div class="line">数据类型--&gt;引用数据类型;</div><div class="line">引用数据类型--&gt;类;</div><div class="line">引用数据类型--&gt;接口;</div><div class="line">引用数据类型--&gt;数组;</div><div class="line">基本数据类型--&gt;数值型;</div><div class="line">数值型--&gt;整数类型;</div><div class="line">数值型--&gt;浮点类型;</div><div class="line">基本数据类型--&gt;字符型;</div><div class="line">基本数据类型--&gt;布尔型;</div></pre></td></tr></table></figure>
<p><img src="https://sarience.github.io//img/pic/parampass1.png" alt=""></p>
<h3 id="修饰符访问权限"><a href="#修饰符访问权限" class="headerlink" title="修饰符访问权限"></a>修饰符访问权限</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>本包</th>
<th>子类</th>
<th>外部包</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>X</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody>
</table>
<h3 id="基本数据类型传递只传递值"><a href="#基本数据类型传递只传递值" class="headerlink" title="基本数据类型传递只传递值"></a>基本数据类型传递只传递值</h3><p>如上代码：change1(int a)()方法执行的时候，在栈中开辟了一段空间，为方法体中的局部变量a赋值为传递过来的值，方法结束后，这段空间出栈被销毁，局部变量a也被销毁，但是main()方法中的a没有被销毁，因为他们不是同一个变量，作用域不同，所处栈空间也不同。</p>
<h3 id="引用类型传递的是地址"><a href="#引用类型传递的是地址" class="headerlink" title="引用类型传递的是地址"></a>引用类型传递的是地址</h3><p>如上代码：String作为引用类型，在调用change1(String str)()方法的时候，给方法体中的局部变量str付给main中变量str的地址，即指向字符常量“main”，重点在<code>str = &quot;change1&quot;;</code>这段代码，这句话其实执行了两句，一句是：<code>new String();</code>，另一句是:给这个<code>new String()</code>对象赋值，即<code>str=new String(&quot;change1&quot;)</code>。这意味着局部变量str的地址指向了新创建的匿名String对象，且这个对象的值为“change1”，在方法结束后，这段空间出栈被销毁，局部变量str也被销毁，匿名String对象没了引用，就变成了垃圾，等待jvm回收。</p>
<p>对于具体的类对象，如上代码，先创建了一个学生对象，赋初始值为：age=20, name=’BFS’, gender=false，在调用change1(Student student)()方法的时候，传递变量bfs的地址过去赋给局部变量student，此时，main中的变量bfs和change1中的局部变量student指向同一个对象，即赋初始值为：age=20, name=’BFS’, gender=false的student对象。此时student调用的方法即是该对象的方法，修改的值也为该对象的值。</p>
]]></content>
      
        <categories>
            
            <category> CoreJava </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CoreJava </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[links]]></title>
      <url>/links/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[gallery]]></title>
      <url>/gallery/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于我]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>小寒赏梅，出门见山茶，窗台开水仙；大寒深山有瑞香，厅前兰花友，煎山矾三钱，茶饮暖心；立春一簇迎春黄，一路春好处，转眼樱桃红，望春一树粉紫紫；雨水湿菜花，换上棉布裙，深巷杏花闹，看村外李花笑枝头；惊蛰一声，桃花开成诗，棣棠忘忧，铺上宣纸，画蔷薇半窗花成海；春分时节，于一枝海棠上，捉住“小蕾深藏数点红”，篱落边梨花白，木兰本素艳，风吹腻粉开；清明春深处，桐花落，麦花写信，柳花读；待到谷雨，牡丹花前绘满月，荼蘼一开，楝花蔌蔌落清香，何尝不是一个女子对岁月最深情的落款。<br><img src="https://sarience.github.io/img/pic/about.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
